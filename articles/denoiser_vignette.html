<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Filtering data â€¢ denoiser</title>
<script src="../lightswitch.js"></script><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Filtering data">
<script type="text/javascript" async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top " aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">denoiser</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-usage" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Usage</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-usage">
<li><a class="dropdown-item" href="../articles/getting_started.html">Getting started</a></li>
    <li><a class="dropdown-item" href="../articles/noiser_vignette.html">Adding noise</a></li>
    <li><a class="dropdown-item" href="../articles/denoiser_vignette.html">Filtering data</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="nav-link" href="https://github.com/ndpvh/denoiser/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-lightswitch" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true" aria-label="Light switch"><span class="fa fa-sun"></span></button>
  <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="dropdown-lightswitch">
<li><button class="dropdown-item" data-bs-theme-value="light"><span class="fa fa-sun"></span> Light</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="dark"><span class="fa fa-moon"></span> Dark</button></li>
    <li><button class="dropdown-item" data-bs-theme-value="auto"><span class="fa fa-adjust"></span> Auto</button></li>
  </ul>
</li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Filtering data</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/ndpvh/denoiser/blob/main/vignettes/denoiser_vignette.Rmd"><code>vignettes/denoiser_vignette.Rmd</code></a></small>
      <div class="d-none name"><code>denoiser_vignette.Rmd</code></div>
    </div>

    
    
<p>The second important functionality of the package is to filter
positional data to get rid of the noise inherent to these data. This is
a useful feature both when setting up recovery studies and when trying
to analyze your own positional data. The primary function to use when
filtering data is <code>denoiser</code>, the functionality of which will
be explained in this vignette.</p>
<div class="section level2">
<h2 id="filters">Filters<a class="anchor" aria-label="anchor" href="#filters"></a>
</h2>
<p>The <code>denoiser</code> function makes use of two types of filters
that one can use and that have been proven (somewhat) effective when
dealing with positional data. These two filters are the Kalman filter
and a binning of the data, both of which will be described
separately.</p>
<div class="section level3">
<h3 id="kalman-filter">Kalman filter<a class="anchor" aria-label="anchor" href="#kalman-filter"></a>
</h3>
<p>The Kalman filter is a popular filtering technique often encountered
in time-series modeling or the modeling of movement to retrieve
<em>latent</em> states of the variables you are interested in while
accounting for the properties of the <em>measurements</em>. Central to
the Kalman filter is the definition of a <em>movement equation</em> and
a <em>measurement equation</em>, the former of which defines how we
expect the latent state to change over time and the latter of which
defines how the measurements or observations should be related to these
latent states (see again <a href="https://ndpvh.github.io/denoiser/articles/noiser_vignette.html" class="external-link">Adding
noise</a>). The definition of the movement equation can be achieved
through specifying the parameters of the following equation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ±</mi><mi>i</mi></msub><mo>=</mo><mi>F</mi><msub><mi>ğ±</mi><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>B</mi><msub><mi>ğ®</mi><mi>i</mi></msub><mo>+</mo><msub><mi>ğ›œ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
  \bm{x}_i = F \bm{x}_{i - 1} + B \bm{u}_i + \bm{\epsilon}_{i}
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\bm{x}_i</annotation></semantics></math>
contains the values of the relevant latent variables at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>i</mi></msub><annotation encoding="application/x-tex">t_i</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
is the matrix relating values of these latent variables at a previous
time point to the next one,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>
is a matrix that scales the values of exogeneous inputs
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ®</mi><annotation encoding="application/x-tex">\bm{u}</annotation></semantics></math>,
and $ represents noise at the latent level. Similarly, the measurement
equation can be defined through specifying the parameters of the
following equation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ³</mi><mi>i</mi></msub><mo>=</mo><mi>H</mi><msub><mi>ğ±</mi><mi>i</mi></msub><mo>+</mo><msub><mi>ğ²</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
  \bm{z}_i = H \bm{x}_i + \bm{y}_i
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
is the measurement matrix, relating the observed states
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ³</mi><annotation encoding="application/x-tex">\bm{z}</annotation></semantics></math>
to the latent state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ±</mi><annotation encoding="application/x-tex">\bm{x}</annotation></semantics></math>,
and where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ²</mi><annotation encoding="application/x-tex">\bm{y}</annotation></semantics></math>
represents the innovation, that is the part that is not captured by
accounting for the latent state and should, in theory, contain the
measurement error.</p>
<p>Note that in these equations, I deviate from the mathematical
conventions used in the other vignettes. This is to align myself with
the literature around the Kalman filter, making it easier for those not
familiar with the Kalman filter to inform themselves when diving in the
literature.</p>
<div class="section level4">
<h4 id="three-step-procedure">Three-step procedure<a class="anchor" aria-label="anchor" href="#three-step-procedure"></a>
</h4>
<p>Once the parameters are defined, then the Kalman filter attempts to
recover the underlying process
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ±</mi><annotation encoding="application/x-tex">\bm{x}</annotation></semantics></math>
through filtering each observation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ³</mi><annotation encoding="application/x-tex">\bm{z}</annotation></semantics></math>
using a three-step procedure.</p>
<div class="section level5">
<h5 id="prediction-step">Prediction step<a class="anchor" aria-label="anchor" href="#prediction-step"></a>
</h5>
<p>In the first step, the Kalman filter will use the movement equation
to predict the next value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ±</mi><annotation encoding="application/x-tex">\bm{x}</annotation></semantics></math>
based on its previous value. In equations:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ±</mi><mi>i</mi></msub><mo>=</mo><mi>F</mi><msub><mi>ğ±</mi><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>B</mi><msub><mi>ğ®</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
  \bm{x}_i = F \bm{x}_{i - 1} + B \bm{u}_i
\end{equation}</annotation></semantics></math> This serves as the point
prediction of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\bm{x}_i</annotation></semantics></math>
at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>i</mi></msub><annotation encoding="application/x-tex">t_i</annotation></semantics></math>.
However, the Kalman filter also accounts for the certainty of this
prediction, which it computes as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub><mo>=</mo><mi>F</mi><msub><mi>P</mi><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><msup><mi>F</mi><mi>T</mi></msup><mo>+</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
  P_i = F P_{i - 1} F^T + W
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">P_{i - 1}</annotation></semantics></math>
is the prior certainty matrix set around the initial condition
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">\bm{x}_{i - 1}</annotation></semantics></math>.
If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = 1</annotation></semantics></math>,
then this represents the prior covariance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>0</mn></msub><annotation encoding="application/x-tex">P_0</annotation></semantics></math>
and prior expectation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\bm{x}_0</annotation></semantics></math>,
which should be specified by the user. If
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i &gt; 1</annotation></semantics></math>,
then these represent the previously computed (and updated) values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ±</mi><annotation encoding="application/x-tex">\bm{x}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>.</p>
<p>In this equation,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
represents the innovation covariance matrix, that is the covariance
around
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ›œ</mi><annotation encoding="application/x-tex">\bm{\epsilon}</annotation></semantics></math>
specified in the movement equation. It is assumed that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ğ›œ</mi><mover><mo>âˆ¼</mo><mrow><mi>i</mi><mi>i</mi><mi>d</mi></mrow></mover><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>ğŸ</mn><mo>,</mo><mi>W</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
  \bm{\epsilon} \overset{iid}{\sim} N(\bm{0}, W)
\end{equation}</annotation></semantics></math> Similar to the initial
conditions of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ±</mi><annotation encoding="application/x-tex">\bm{x}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>,
the value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
should also be provided by the user.</p>
<p>Once the prediction
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\bm{x}_i</annotation></semantics></math>
and its certainty
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mi>i</mi></msub><annotation encoding="application/x-tex">P_i</annotation></semantics></math>
have been computed, we can move on to the next step of the Kalman
filter.</p>
</div>
<div class="section level5">
<h5 id="innovation-step">Innovation step<a class="anchor" aria-label="anchor" href="#innovation-step"></a>
</h5>
<p>In the second step, we use the measurement equation to find out how
close our prediction
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\bm{x}_i</annotation></semantics></math>
lies to the actual observation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ³</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\bm{z}_i</annotation></semantics></math>.
Specifically, we compute the <em>innovation</em>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ²</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\bm{y}_i</annotation></semantics></math>
as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ²</mi><mi>i</mi></msub><mo>=</mo><msub><mi>ğ³</mi><mi>i</mi></msub><mo>âˆ’</mo><mi>H</mi><msub><mi>ğ±</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
  \bm{y}_i = \bm{z}_i - H \bm{x}_i
\end{equation}</annotation></semantics></math> Similar to the prediction
step, we again which to quantify the certainty around this innovation,
which we achieve through computing its covariance matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î£</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\Sigma_i</annotation></semantics></math>:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Î£</mi><mi>i</mi></msub><mo>=</mo><mi>H</mi><msub><mi>P</mi><mi>i</mi></msub><msup><mi>H</mi><mi>T</mi></msup><mo>+</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
  \Sigma_i = H P_i H^T + R
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
is the measurement covariance matrix, representing the covariance of the
measurement error. Like for the values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\bm{x}_0</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\bm{P}_0</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>,
the values in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>
should also be provided by the user.</p>
<p>An important realization that we should have at this point is that we
have quantified not only the certainty around our prediction through
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mi>i</mi></msub><annotation encoding="application/x-tex">P_i</annotation></semantics></math>,
but also around the process in full through
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>Î£</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\Sigma_i</annotation></semantics></math>.
Putting these two covariance matrices against each other therefore
provides us with something of a reliability measure: How much can we
trust our measurements over our predictions and vice-versa, and which of
the two should we trust when estimating the latent values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ±</mi><annotation encoding="application/x-tex">\bm{x}</annotation></semantics></math>?
This is exactly what is achieved when computing the Kalman gain, which
is defined as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>i</mi></msub><mo>=</mo><msub><mi>P</mi><mi>i</mi></msub><msup><mi>H</mi><mi>T</mi></msup><msubsup><mi>Î£</mi><mi>i</mi><mrow><mo>âˆ’</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">\begin{equation}
  K_i = P_i H^T \Sigma_i^{-1}
\end{equation}</annotation></semantics></math> which will play an
important role in updating our estimate of the latent process
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ±</mi><annotation encoding="application/x-tex">\bm{x}</annotation></semantics></math>
based on the movement and measurement equations.</p>
</div>
<div class="section level5">
<h5 id="updating-step">Updating step<a class="anchor" aria-label="anchor" href="#updating-step"></a>
</h5>
<p>The final step consists of estimating the values of the latent
process
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\bm{x}_i</annotation></semantics></math>
and the certainty around this estimate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\bm{P}_i</annotation></semantics></math>.
This is achieved through the following set of equations, each of which
concerns a weighted sum of the prediction according to the movement
equation and the observation according to the measurement equation. The
Kalman gain
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>
represents the weights that determine the strength of the prediction
versus the observation, again basing this weight on the presumed amount
of information either the observation or the prediction hold.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>ğ±</mi><mo accent="true">Ì‚</mo></mover><mi>i</mi></msub><mo>=</mo><msub><mi>ğ±</mi><mi>i</mi></msub><mo>+</mo><mi>K</mi><msub><mi>ğ²</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
  \hat{\bm{x}}_i = \bm{x}_i + K \bm{y}_i
\end{equation}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover><mi>P</mi><mo accent="true">Ì‚</mo></mover><mi>i</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>I</mi><mo>âˆ’</mo><mi>K</mi><mi>H</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
  \hat{P}_i = (I - K H) P_i
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>
is the identity matrix.</p>
<p>This concludes the three-step procedure of the Kalman filter, after
which it will move to the prediction step for the next datapoint
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">\bm{x}_{i + 1}</annotation></semantics></math>
at the next time point
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">t_{i + 1}</annotation></semantics></math>.
In this prediction step, the estimated values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>ğ±</mi><mo accent="true">Ì‚</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\hat{\bm{x}}_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>P</mi><mo accent="true">Ì‚</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\hat{P}_i</annotation></semantics></math>
serve as the initial conditions.</p>
</div>
</div>
<div class="section level4">
<h4 id="kalman-models">Kalman models<a class="anchor" aria-label="anchor" href="#kalman-models"></a>
</h4>
<p>Up to now, the discussion has been quite vague: It has specified how
the Kalman filter works without going into details of what each of its
parameters represents. The strength of the Kalman filter is exactly this
generality. It works for any set of movement and measurement equations
that can fit within the general structure outlined above. As to how to
define these equations, thatâ€™s left up to the user.</p>
<p>Within the <code>denoiser</code> package, we specify only a single
set of movement and measurement equations that are used to filter the
data. This model is called the <em>constant velocity</em> model,
reflecting its underlying assumption that the subject is moving at
constant velocity, meaning changes in acceleration are taken as part of
the measurement error. This model was used in our previous project and
has been found to be (somewhat) effective at handling the measurement
error observed in our experiments, which is why it is included here.</p>
<p>In this vignette, I will focus mostly on the definition of the
parameters rather than the reasoning behind the model. For this, I refer
the interested reader to the explanation of the <a href="https://ndpvh.github.io/denoiser/reference/constant_velocity.html" class="external-link">constant_velocity</a>
function instead.</p>
<div class="section level5">
<h5 id="constant-velocity-model">Constant velocity model<a class="anchor" aria-label="anchor" href="#constant-velocity-model"></a>
</h5>
<p>The constant velocity model operates under the assumption that the
latent position changes in the following way:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>x</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>y</mi></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mi>i</mi></msub><mo>=</mo><msub><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>x</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>y</mi></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><mo>+</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>v</mi><mi>x</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>v</mi><mi>y</mi></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mi>Î”</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\begin{equation}
  \begin{bmatrix}
    x \\
    y
  \end{bmatrix}_i = \begin{bmatrix}
    x \\
    y
  \end{bmatrix}_{i - 1} + \begin{bmatrix}
    v_x \\
    v_y
  \end{bmatrix} \Delta t
\end{equation}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mi>x</mi></msub><annotation encoding="application/x-tex">v_x</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mi>y</mi></msub><annotation encoding="application/x-tex">v_y</annotation></semantics></math>
represent the speed in dimensions x and y, and where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î”</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math>
represents the time interval between observations. Under this
specification, we have to define the latent state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ±</mi><annotation encoding="application/x-tex">\bm{x}</annotation></semantics></math>
as a four-dimensional vector, taking into account both position and
speed so that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ğ±</mi><mi>i</mi></msub><mo>=</mo><msub><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>x</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>y</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>v</mi><mi>x</mi></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>v</mi><mi>y</mi></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
  \bm{x}_i = \begin{bmatrix}
    x \\
    y \\
    v_x \\
    v_y
  \end{bmatrix}_i
\end{equation}</annotation></semantics></math></p>
<p>For the movement equation, we then have to define the
four-dimensional matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>,
both of which depend on time interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î”</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math>,
so that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub><mo>=</mo><msub><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mi>Î”</mi><mi>t</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mi>Î”</mi><mi>t</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
  F_i = \begin{bmatrix} 
    1 &amp; 0 &amp; \Delta t &amp; 0 \\  
    0 &amp; 1 &amp; 0 &amp; \Delta t \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
  \end{bmatrix}_i
\end{equation}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>W</mi><mi>i</mi></msub><mo>=</mo><msub><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>Î”</mi><msup><mi>t</mi><mn>2</mn></msup><msubsup><mi>Ïƒ</mi><msub><mi>v</mi><mi>x</mi></msub><mn>2</mn></msubsup></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mi>Î”</mi><mi>t</mi><msubsup><mi>Ïƒ</mi><msub><mi>v</mi><mi>x</mi></msub><mn>2</mn></msubsup></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mi>Î”</mi><msup><mi>t</mi><mn>2</mn></msup><msubsup><mi>Ïƒ</mi><msub><mi>v</mi><mi>y</mi></msub><mn>2</mn></msubsup></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mi>Î”</mi><mi>t</mi><msubsup><mi>Ïƒ</mi><msub><mi>v</mi><mi>y</mi></msub><mn>2</mn></msubsup></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>Î”</mi><mi>t</mi><msubsup><mi>Ïƒ</mi><msub><mi>v</mi><mi>x</mi></msub><mn>2</mn></msubsup></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><msubsup><mi>Ïƒ</mi><msub><mi>v</mi><mi>x</mi></msub><mn>2</mn></msubsup></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mi>Î”</mi><mi>t</mi><msubsup><mi>Ïƒ</mi><msub><mi>v</mi><mi>y</mi></msub><mn>2</mn></msubsup></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><msubsup><mi>Ïƒ</mi><msub><mi>v</mi><mi>y</mi></msub><mn>2</mn></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
  W_i = \begin{bmatrix}
    \Delta t^2 \sigma_{v_x}^2 &amp; 0 &amp; \Delta t \sigma_{v_x}^2 &amp; 0 \\
    0 &amp; \Delta t^2 \sigma_{v_y}^2 &amp; 0 &amp; \Delta t \sigma_{v_y}^2 \\
    \Delta t \sigma_{v_x}^2 &amp; 0 &amp; \sigma_{v_x}^2 &amp; 0 \\
    0 &amp; \Delta t \sigma_{v_y}^2 &amp; 0 &amp; \sigma_{v_y}^2
  \end{bmatrix}_i
\end{equation}</annotation></semantics></math> Notice that if you fill
compute
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub><msub><mi>ğ±</mi><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">F_i \bm{x}_{i - 1}</annotation></semantics></math>,
you will get back the original equation for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>,
showing that these parameters do indeed conform to our assume movement
equation. Furthermore note that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>W</mi><mi>i</mi></msub><annotation encoding="application/x-tex">W_i</annotation></semantics></math>
can be obtained by assuming some error on the speed variables
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mi>x</mi></msub><annotation encoding="application/x-tex">v_x</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mi>y</mi></msub><annotation encoding="application/x-tex">v_y</annotation></semantics></math>
and, similarly, working this out according to the movement equation
denoted above.</p>
<p>For the measurement equation, we have to define the measurement
matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
which connects the underlying latent movement model and the observations
that we make. In <code>denoiser</code>, we assume that we only measured
positions without any indication of speeds, meaning that our measurement
matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>
will have to reduce information so that:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
  H = \begin{bmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0
  \end{bmatrix}
\end{equation}</annotation></semantics></math> Again notice that using
this measurement matrix on the previously computed values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mi>i</mi></msub><msub><mi>ğ±</mi><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">F_i \bm{x}_{i - 1}</annotation></semantics></math>,
you will automatically get back the movement equation denoted above in
terms of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>.</p>
<p>On the level of the measurement equation, we also have to define the
measurement covariance matrix R, which for our purposes is defined
as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msubsup><mi>Ïƒ</mi><mi>R</mi><mn>2</mn></msubsup></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><msubsup><mi>Ïƒ</mi><mi>R</mi><mn>2</mn></msubsup></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
  R = \begin{bmatrix}
    \sigma_R^2 &amp; 0 \\
    0 &amp; \sigma_R^2
  \end{bmatrix}
\end{equation}</annotation></semantics></math></p>
<p>In its current specification, there are still several parameters that
need to be specified by the user. This includes the initial conditions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\bm{x}_0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>0</mn></msub><annotation encoding="application/x-tex">P_0</annotation></semantics></math>,
the measurement variance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>Ïƒ</mi><mi>R</mi><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma_R^2</annotation></semantics></math>,
and the movement variances
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>Ïƒ</mi><msub><mi>v</mi><mi>x</mi></msub><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma_{v_x}^2</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>Ïƒ</mi><msub><mi>v</mi><mi>y</mi></msub><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma_{v_y}^2</annotation></semantics></math>.</p>
<p>In <code>denoiser</code>, we specify broad though data-driven priors.
Specifically, we defined the initial condition
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\bm{x}_0</annotation></semantics></math>
as the vector of mean x- and y-positions alongside mean speeds in the x-
and y-direction. The prior covariance matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mn>0</mn></msub><annotation encoding="application/x-tex">P_0</annotation></semantics></math>
is defined as the diagonal matrix of observed variances for these same
variables in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mn>0</mn></msub><annotation encoding="application/x-tex">\bm{x}_0</annotation></semantics></math>.
These broad priors were defined for practical utility, but may not be
fit for each use-case.</p>
<p>For the variances, we require users to specify the assumed error
variance
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>Ïƒ</mi><mi>R</mi><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma_R^2</annotation></semantics></math>
through the <code>error</code> argument (see later). Based on the
provided error variance and the observed variances in the data, we then
specify the speed variances to be:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>Ïƒ</mi><mi>v</mi><mn>2</mn></msubsup><mo>=</mo><msup><mi>Ïƒ</mi><mtext mathvariant="normal">obs</mtext></msup><mo>âˆ’</mo><mfrac><mn>2</mn><mrow><mi>E</mi><msup><mrow><mo stretchy="true" form="prefix">[</mo><mi>Î”</mi><mi>t</mi><mo stretchy="true" form="postfix">]</mo></mrow><mn>2</mn></msup></mrow></mfrac><msubsup><mi>Ïƒ</mi><mi>R</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\begin{equation}
  \sigma_{v}^2 = \sigma^\text{obs} - \frac{2}{E[\Delta t]^2} \sigma_R^2
\end{equation}</annotation></semantics></math> therefore dividing up the
observed variance in a measurement error component (second part on
right-hand side) and a movement component (left-hand side). Note that
these variances of the speeds are computed for both dimensions
separately.</p>
</div>
<div class="section level5">
<h5 id="reality-vs-model">Reality vs model<a class="anchor" aria-label="anchor" href="#reality-vs-model"></a>
</h5>
<p>With the constant velocity model out of the way, a cautionary note is
warranted. As mentioned before, the Kalman filter operates on the
weighting of observations against predictions of the movement model.
This means that if predictions are very wrong, then the Kalman filter
will find no useful information in these predictions and the best guess
it has about the latent state
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ±</mi><annotation encoding="application/x-tex">\bm{x}</annotation></semantics></math>
will be the observations
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ğ³</mi><annotation encoding="application/x-tex">\bm{z}</annotation></semantics></math>.
This means that the results of the Kalman filter will be very sensitive
to the specification of the Kalman model: If predictions are off, then
they will not allow us filter the data sufficiently, and similarly if
measurement specifications are off. In other words, it is useful to
carefully consider whether the specified model is fit for use on the
data you have obtained.</p>
</div>
</div>
</div>
<div class="section level3">
<h3 id="binning">Binning<a class="anchor" aria-label="anchor" href="#binning"></a>
</h3>
<p>A second filtering technique that is natively supported by
<code>denoiser</code> is binning. Binning operates under the assumption
that if we cannot be certain about the position
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\bm{x}_i</annotation></semantics></math>
at a given time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>i</mi></msub><annotation encoding="application/x-tex">t_i</annotation></semantics></math>,
that we may be able to aleviate some of the noise contained within a
single observation by averaging over several such observations within a
particular time interval. In this case, we are not talking about a
single position
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ğ±</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\bm{x}_i</annotation></semantics></math>
at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>i</mi></msub><annotation encoding="application/x-tex">t_i</annotation></semantics></math>
anymore, but rather about the average position
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>ğ±</mi><mo accent="true">â€¾</mo></mover><mi>j</mi></msub><annotation encoding="application/x-tex">\bm{\bar{x}}_j</annotation></semantics></math>
within the bin
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>
ranging from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mrow><mi>j</mi><mo>âˆ’</mo><mn>1</mn></mrow></msub><annotation encoding="application/x-tex">t_{j - 1}</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mi>j</mi></msub><annotation encoding="application/x-tex">t_j</annotation></semantics></math>.</p>
<p>Binning represents a reduction in the data that was necessarily part
of our previous endeavors, as our experimental data was usually sampled
at 6Hz while our model itself only operates on a 2Hz timescale. Because
it may prove useful to other researchers, I also included it in the
package. Note, however, that binning is made optional and should
explicitly be called for through setting the argument
<code>binning = TRUE</code>.</p>
</div>
</div>
<div class="section level2">
<h2 id="using-denoiser">Using <code>denoiser</code><a class="anchor" aria-label="anchor" href="#using-denoiser"></a>
</h2>
<p>With the mathematics out of the way, we can now focus on how to use
the <code>denoiser</code> function itself to filter oneâ€™s data.
Throughout, we will use a â€œnoised upâ€ dataset called <code>data</code>
that displays circular motion.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Define the simulated angles of the observations</span></span>
<span><span class="va">angles</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">2</span> <span class="op">*</span> <span class="va">pi</span>, length.out <span class="op">=</span> <span class="fl">50</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Define the dataset itself</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  time <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">50</span>, </span>
<span>  x <span class="op">=</span> <span class="fl">10</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html" class="external-link">cos</a></span><span class="op">(</span><span class="va">angles</span><span class="op">)</span>,</span>
<span>  y <span class="op">=</span> <span class="fl">10</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html" class="external-link">sin</a></span><span class="op">(</span><span class="va">angles</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Add noise to the data</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/noiser.html">noiser</a></span><span class="op">(</span></span>
<span>  <span class="va">data</span>, </span>
<span>  model <span class="op">=</span> <span class="st">"independent"</span>,</span>
<span>  mean <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span>, </span>
<span>  covariance <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span> <span class="op">*</span> <span class="fl">0.5</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Plot these data</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">data</span><span class="op">$</span><span class="va">x</span>, <span class="va">data</span><span class="op">$</span><span class="va">y</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="denoiser_vignette_files/figure-html/unnamed-chunk-2-1.png" class="r-plt" alt="One sees 50 dots placed on the circumference of a circle, albeit with some noise around them.
" width="75%"><p class="caption">
<em>Measured positions on a plane representing circular motion. Error
was added according to the independent measurement model.</em>
</p>
</div>
<p>Now that the data have been created, we can attempt to filter these
data through the <code>denoiser</code> function. In a first step, we are
only interested in applying the Kalman filter to these data, so that we
call:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Add noise to the data</span></span>
<span><span class="va">denoised</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/denoiser-function.html">denoiser</a></span><span class="op">(</span></span>
<span>  <span class="va">data</span>, </span>
<span>  model <span class="op">=</span> <span class="st">"constant_velocity"</span>,</span>
<span>  error <span class="op">=</span> <span class="fl">0.5</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Plot the noised up data</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">denoised</span><span class="op">$</span><span class="va">x</span>, <span class="va">denoised</span><span class="op">$</span><span class="va">y</span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="denoiser_vignette_files/figure-html/unnamed-chunk-3-1.png" class="r-plt" alt="One sees 50 dots placed on the circumference of a circle, albeit with some added noise around the latent positions that were plotted before.
" width="75%"><p class="caption">
<em>Filtered positions as achieved through the <code>denoiser</code>
function.</em>
</p>
</div>
<p>Several things are of note here. First, we had to provide a value to
the argument <code>error</code>, which represents
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>Ïƒ</mi><mi>R</mi><mn>2</mn></msubsup><annotation encoding="application/x-tex">\sigma_R^2</annotation></semantics></math>
in the constant velocity model. This is an argument immediately provided
to the <a href="https://ndpvh.github.io/denoiser/reference/constant_velocity.html" class="external-link">constant_velocity</a>
function to derive the necessary parameters.</p>
<p>Second, when comparing the noisy and filtered data, one may see a
slight improvement, but by no means a definite one. This may be due to
several reasons. For example, our initial conditions may be too broad,
not allowing for the Kalman filter to converge on a good weighting of
the measurements against the predictions. Or our specification of the
measurement error may be wrong, again influencing the weighting of the
measurements against the predictions. Or finally, the constant velocity
model itself may be wrong, assuming a constant velocity in both the x-
and y-direction may be too restrictive and may therefore influence the
validity of the predictions. To find out which of these is correct, one
has to play around with the specification of the parameters (see the <a href="https://ndpvh.github.io/denoiser/reference/constant_velocity.html" class="external-link">constant_velocity</a>
function).</p>
<div class="section level3">
<h3 id="nonstandard-column-names-and-grouping">Nonstandard column names and grouping<a class="anchor" aria-label="anchor" href="#nonstandard-column-names-and-grouping"></a>
</h3>
<p>The <code>denoiser</code> function works in largely the same way as
the <code>noiser</code> function, meaning that their functionality is
largely the same. This applies to nonstandard column names and grouping
as well, the details for which can be found in the vignette for <a href="https://ndpvh.github.io/denoiser/articles/noiser_vignette.html" class="external-link">Adding
noise</a>. Bringing it to practice, we can combine both pieces of info
as follows:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Define the angles</span></span>
<span><span class="va">angles</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">2</span> <span class="op">*</span> <span class="va">pi</span>, length.out <span class="op">=</span> <span class="fl">50</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Create data for two participants, each walking in a circle but a few meters away from each other</span></span>
<span><span class="va">data_1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  seconds <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">50</span>, </span>
<span>  X <span class="op">=</span> <span class="fl">10</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html" class="external-link">cos</a></span><span class="op">(</span><span class="va">angles</span><span class="op">)</span>,</span>
<span>  Y <span class="op">=</span> <span class="fl">10</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html" class="external-link">sin</a></span><span class="op">(</span><span class="va">angles</span><span class="op">)</span>,</span>
<span>  person <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="op">)</span></span>
<span><span class="va">data_2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  seconds <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">50</span>,</span>
<span>  X <span class="op">=</span> <span class="fl">5</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html" class="external-link">cos</a></span><span class="op">(</span><span class="va">angles</span><span class="op">)</span> <span class="op">+</span> <span class="fl">5</span>,</span>
<span>  Y <span class="op">=</span> <span class="fl">5</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Trig.html" class="external-link">sin</a></span><span class="op">(</span><span class="va">angles</span><span class="op">)</span> <span class="op">+</span> <span class="fl">5</span>,</span>
<span>  person <span class="op">=</span> <span class="fl">2</span></span>
<span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">data_1</span>, <span class="va">data_2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Mention the additional columns explicitly in the mapping</span></span>
<span><span class="va">mapping</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span></span>
<span>  <span class="st">"time"</span> <span class="op">=</span> <span class="st">"seconds"</span>,</span>
<span>  <span class="st">"x"</span> <span class="op">=</span> <span class="st">"X"</span>,</span>
<span>  <span class="st">"y"</span> <span class="op">=</span> <span class="st">"Y"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Add noise to these data with the columns being provided</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/noiser.html">noiser</a></span><span class="op">(</span></span>
<span>  <span class="va">data</span>, </span>
<span>  cols <span class="op">=</span> <span class="va">mapping</span>,</span>
<span>  .by <span class="op">=</span> <span class="st">"person"</span>,</span>
<span>  model <span class="op">=</span> <span class="st">"independent"</span>,</span>
<span>  mean <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span>,</span>
<span>  covariance <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span> <span class="op">*</span> <span class="fl">0.5</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Filter these data</span></span>
<span><span class="va">denoised</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/denoiser-function.html">denoiser</a></span><span class="op">(</span></span>
<span>  <span class="va">data</span>, </span>
<span>  cols <span class="op">=</span> <span class="va">mapping</span>,</span>
<span>  .by <span class="op">=</span> <span class="st">"person"</span>,</span>
<span>  model <span class="op">=</span> <span class="st">"constant_velocity"</span>,</span>
<span>  error <span class="op">=</span> <span class="fl">0.5</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">denoised</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   seconds         X          Y person</span></span>
<span><span class="co">## 1       1  9.603610 -0.2709594      1</span></span>
<span><span class="co">## 2       2  9.800417  0.5828054      1</span></span>
<span><span class="co">## 3       3 10.398862  1.7091015      1</span></span>
<span><span class="co">## 4       4  9.880234  3.0982147      1</span></span>
<span><span class="co">## 5       5  8.283371  3.8024455      1</span></span>
<span><span class="co">## 6       6  7.458583  5.3335179      1</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="specifying-your-own-kalman-model">Specifying your own Kalman model<a class="anchor" aria-label="anchor" href="#specifying-your-own-kalman-model"></a>
</h3>
<p>The <code>denoiser</code> function allows users to specify their own
Kalman model and to provide it as a function to the argument
<code>model</code>. The specification and use of this argument is the
same as for <code>noiser</code> and, given that the specification of
such a model relatively complicated, I refer the interested reader to
the vignette on <a href="https://ndpvh.github.io/denoiser/articles/noiser_vignette.html" class="external-link">Adding
noise</a> for more information on the use of this argument. For our
purposes, though, there are several things that need to be taken into
account when specifying your own Kalman models.</p>
<p>First, the function should use the data structure that is assumed
within the whole <code>denoiser</code> package. That means that the time
variable is contained under the column <code>time</code> and the
positions are contained under the columns <code>x</code> and
<code>y</code>. There is not need to account for the grouping variable:
This is handled under the hood.</p>
<p>Second, the function should in the least take as input
<code>data</code>, but can take in more arguments. When using the
<code>denoiser</code> function, you can specify the value for these
arguments next to the specification of the model: Their value will be
given to the function provided in <code>model</code> in the same way
that the value of <code>error</code> in our examples is handed down to
the <code>constant_velocity</code> function.</p>
<p>Finally, the function should output a named list containing values
for <code>"z"</code> (the data to be smoothed), <code>"x"</code> and
<code>"P"</code> (initial conditions), <code>"F"</code>,
<code>"W"</code>, and <code>"B"</code> (parameters of the movement
equation), <code>"u"</code> (values for the exogeneous variables), and
<code>"H"</code> and <code>"R"</code> (parameters of the measurement
equation). The Kalman filter assumes that the values of <code>"F"</code>
and <code>"W"</code> are functions that take in a single argument,
namely the time between observations
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Î”</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">\Delta t</annotation></semantics></math>
(see again the equations above). It is furthermore also assumed that the
data provided to <code>"z"</code> contains the columns <code>x</code>
and <code>y</code> (containing the measured positions) and
<code>delta_t</code> (containing the time since the previous
observation).</p>
</div>
<div class="section level3">
<h3 id="binning-the-data">Binning the data<a class="anchor" aria-label="anchor" href="#binning-the-data"></a>
</h3>
<p>If the user wishes, they can also bin the data after applying the
Kalman filter. They can do so by setting <code>binned</code> to
<code>TRUE</code> and specifying a certain range of the bins
(<code>span</code>) and a given function to apply to the data within the
bin (<code>fx</code>). For example, assuming <code>time</code> is
specified on the seconds level, then we can bin together data with a
span of 5 seconds and by taking a mean in the following way:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">denoised</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/denoiser-function.html">denoiser</a></span><span class="op">(</span></span>
<span>  <span class="va">data</span>, </span>
<span>  cols <span class="op">=</span> <span class="va">mapping</span>,</span>
<span>  .by <span class="op">=</span> <span class="st">"person"</span>,</span>
<span>  model <span class="op">=</span> <span class="st">"constant_velocity"</span>,</span>
<span>  error <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>  binned <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  span <span class="op">=</span> <span class="fl">5</span>,</span>
<span>  fx <span class="op">=</span> <span class="va">mean</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">denoised</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##   seconds          X         Y person</span></span>
<span><span class="co">## 1     3.5   9.237513  2.375854      1</span></span>
<span><span class="co">## 2     9.0   5.140405  8.471663      1</span></span>
<span><span class="co">## 3    14.0  -0.642266  9.932376      1</span></span>
<span><span class="co">## 4    19.0  -6.550784  7.636946      1</span></span>
<span><span class="co">## 5    24.0 -10.127518  2.309825      1</span></span>
<span><span class="co">## 6    29.0  -8.830173 -4.431435      1</span></span></code></pre>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span></span>
<span>  <span class="va">denoised</span><span class="op">$</span><span class="va">X</span>, </span>
<span>  <span class="va">denoised</span><span class="op">$</span><span class="va">Y</span>,</span>
<span>  col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">factor</a></span><span class="op">(</span><span class="va">denoised</span><span class="op">$</span><span class="va">person</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<div class="figure">
<img src="denoiser_vignette_files/figure-html/unnamed-chunk-5-1.png" class="r-plt" alt="One sees several dots placed on the circumference of a circle, albeit with some added noise around the latent positions that were plotted before. Importantly, there are fewer dots now then before due to the binning procedure.
" width="75%"><p class="caption">
<em>Filtered and binned positions as achieved through the
<code>denoiser</code> function.</em>
</p>
</div>
<p>Note that to make sense of the time variable, one should realize that
for any
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>âˆˆ</mo><mo stretchy="false" form="prefix">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mi>â‹¯</mi><mi>T</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">i \in \{0, 1, \cdots T\}</annotation></semantics></math>,
we define the bins as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><msub><mi>t</mi><mi>i</mi></msub><mo>+</mo><mi>Î”</mi><mi>t</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">(t_i, t_i + \Delta t]</annotation></semantics></math>
except for the first bin, which is defined as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><msub><mi>t</mi><mi>i</mi></msub><mo>+</mo><mi>Î”</mi><mi>t</mi><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[t_i, t_i + \Delta t]</annotation></semantics></math>.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Niels Vanhasbroeck.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
