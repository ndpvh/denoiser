[{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"filters","dir":"Articles","previous_headings":"","what":"Filters","title":"Filtering data","text":"denoiser function makes use two types filters one can use proven (somewhat) effective dealing positional data. two filters Kalman filter binning data, described separately.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"kalman-filter","dir":"Articles","previous_headings":"Filters","what":"Kalman filter","title":"Filtering data","text":"Kalman filter popular filtering technique often encountered time-series modeling modeling movement retrieve latent states variables interested accounting properties measurements. Central Kalman filter definition movement equation measurement equation, former defines expect latent state change time latter defines measurements observations related latent states (see Adding noise). definition movement equation can achieved specifying parameters following equation: ùê±i=Fùê±i‚àí1+BùêÆi+ùõúi\\begin{equation}   \\bm{x}_i = F \\bm{x}_{- 1} + B \\bm{u}_i + \\bm{\\epsilon}_{} \\end{equation} ùê±i\\bm{x}_i contains values relevant latent variables time tit_i, FF matrix relating values latent variables previous time point next one, BB matrix scales values exogeneous inputs ùêÆ\\bm{u}, $ represents noise latent level. Similarly, measurement equation can defined specifying parameters following equation: ùê≥i=Hùê±i+ùê≤i\\begin{equation}   \\bm{z}_i = H \\bm{x}_i + \\bm{y}_i \\end{equation} HH measurement matrix, relating observed states ùê≥\\bm{z} latent state ùê±\\bm{x}, ùê≤\\bm{y} represents innovation, part captured accounting latent state , theory, contain measurement error. Note equations, deviate mathematical conventions used vignettes. align literature around Kalman filter, making easier familiar Kalman filter inform diving literature.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"three-step-procedure","dir":"Articles","previous_headings":"Filters > Kalman filter","what":"Three-step procedure","title":"Filtering data","text":"parameters defined, Kalman filter attempts recover underlying process ùê±\\bm{x} filtering observation ùê≥\\bm{z} using three-step procedure.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"prediction-step","dir":"Articles","previous_headings":"Filters > Kalman filter > Three-step procedure","what":"Prediction step","title":"Filtering data","text":"first step, Kalman filter use movement equation predict next value ùê±\\bm{x} based previous value. equations: ùê±i=Fùê±i‚àí1+BùêÆi\\begin{equation}   \\bm{x}_i = F \\bm{x}_{- 1} + B \\bm{u}_i \\end{equation} serves point prediction ùê±i\\bm{x}_i time tit_i. However, Kalman filter also accounts certainty prediction, computes : Pi=FPi‚àí1FT+W\\begin{equation}   P_i = F P_{- 1} F^T + W \\end{equation} Pi‚àí1P_{- 1} prior certainty matrix set around initial condition ùê±i‚àí1\\bm{x}_{- 1}. =1i = 1, represents prior covariance P0P_0 prior expectation ùê±0\\bm{x}_0, specified user. >1i > 1, represent previously computed (updated) values ùê±\\bm{x} PP. equation, WW represents innovation covariance matrix, covariance around ùõú\\bm{\\epsilon} specified movement equation. assumed : ùõú‚àºiidN(ùüé,W)\\begin{equation}   \\bm{\\epsilon} \\overset{iid}{\\sim} N(\\bm{0}, W) \\end{equation} Similar initial conditions ùê±\\bm{x} PP, value WW also provided user. prediction ùê±i\\bm{x}_i certainty PiP_i computed, can move next step Kalman filter.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"innovation-step","dir":"Articles","previous_headings":"Filters > Kalman filter > Three-step procedure","what":"Innovation step","title":"Filtering data","text":"second step, use measurement equation find close prediction ùê±i\\bm{x}_i lies actual observation ùê≥i\\bm{z}_i. Specifically, compute innovation ùê≤i\\bm{y}_i : ùê≤i=ùê≥i‚àíHùê±i\\begin{equation}   \\bm{y}_i = \\bm{z}_i - H \\bm{x}_i \\end{equation} Similar prediction step, quantify certainty around innovation, achieve computing covariance matrix Œ£i\\Sigma_i: Œ£i=HPiHT+R\\begin{equation}   \\Sigma_i = H P_i H^T + R \\end{equation} RR measurement covariance matrix, representing covariance measurement error. Like values ùê±0\\bm{x}_0, ùêè0\\bm{P}_0, WW, values RR also provided user. important realization point quantified certainty around prediction PiP_i, also around process full Œ£i\\Sigma_i. Putting two covariance matrices therefore provides us something reliability measure: much can trust measurements predictions vice-versa, two trust estimating latent values ùê±\\bm{x}? exactly achieved computing Kalman gain, defined : Ki=PiHTŒ£i‚àí1\\begin{equation}   K_i = P_i H^T \\Sigma_i^{-1} \\end{equation} play important role updating estimate latent process ùê±\\bm{x} based movement measurement equations.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"updating-step","dir":"Articles","previous_headings":"Filters > Kalman filter > Three-step procedure","what":"Updating step","title":"Filtering data","text":"final step consists estimating values latent process ùê±i\\bm{x}_i certainty around estimate ùêèi\\bm{P}_i. achieved following set equations, concerns weighted sum prediction according movement equation observation according measurement equation. Kalman gain KK represents weights determine strength prediction versus observation, basing weight presumed amount information either observation prediction hold. ùê±ÃÇ=ùê±i+Kùê≤i\\begin{equation}   \\hat{\\bm{x}}_i = \\bm{x}_i + K \\bm{y}_i \\end{equation} PÃÇ=(‚àíKH)Pi\\begin{equation}   \\hat{P}_i = (- K H) P_i \\end{equation} II identity matrix. concludes three-step procedure Kalman filter, move prediction step next datapoint ùê±i+1\\bm{x}_{+ 1} next time point ti+1t_{+ 1}. prediction step, estimated values ùê±ÃÇ\\hat{\\bm{x}}_i PÃÇ\\hat{P}_i serve initial conditions.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"kalman-models","dir":"Articles","previous_headings":"Filters > Kalman filter","what":"Kalman models","title":"Filtering data","text":"now, discussion quite vague: specified Kalman filter works without going details parameters represents. strength Kalman filter exactly generality. works set movement measurement equations can fit within general structure outlined . define equations, ‚Äôs left user. Within denoiser package, specify single set movement measurement equations used filter data. model called constant velocity model, reflecting underlying assumption subject moving constant velocity, meaning changes acceleration taken part measurement error. model used previous project found (somewhat) effective handling measurement error observed experiments, included . vignette, focus mostly definition parameters rather reasoning behind model. , refer interested reader explanation constant_velocity function instead.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"constant-velocity-model","dir":"Articles","previous_headings":"Filters > Kalman filter > Kalman models","what":"Constant velocity model","title":"Filtering data","text":"constant velocity model operates assumption latent position changes following way: [xy]=[xy]‚àí1+[vxvy]Œît\\begin{equation}   \\begin{bmatrix}     x \\\\     y   \\end{bmatrix}_i = \\begin{bmatrix}     x \\\\     y   \\end{bmatrix}_{- 1} + \\begin{bmatrix}     v_x \\\\     v_y   \\end{bmatrix} \\Delta t \\end{equation} vxv_x vyv_y represent speed dimensions x y, Œît\\Delta t represents time interval observations. specification, define latent state ùê±\\bm{x} four-dimensional vector, taking account position speed : ùê±i=[xyvxvy]\\begin{equation}   \\bm{x}_i = \\begin{bmatrix}     x \\\\     y \\\\     v_x \\\\     v_y   \\end{bmatrix}_i \\end{equation} movement equation, define four-dimensional matrix FF WW, depend time interval Œît\\Delta t, : Fi=[10Œît0010Œît00100001]\\begin{equation}   F_i = \\begin{bmatrix}      1 & 0 & \\Delta t & 0 \\\\       0 & 1 & 0 & \\Delta t \\\\     0 & 0 & 1 & 0 \\\\     0 & 0 & 0 & 1   \\end{bmatrix}_i \\end{equation} Wi=[Œît2œÉvx20ŒîtœÉvx200Œît2œÉvy20ŒîtœÉvy2ŒîtœÉvx20œÉvx200ŒîtœÉvy20œÉvy2]\\begin{equation}   W_i = \\begin{bmatrix}     \\Delta t^2 \\sigma_{v_x}^2 & 0 & \\Delta t \\sigma_{v_x}^2 & 0 \\\\     0 & \\Delta t^2 \\sigma_{v_y}^2 & 0 & \\Delta t \\sigma_{v_y}^2 \\\\     \\Delta t \\sigma_{v_x}^2 & 0 & \\sigma_{v_x}^2 & 0 \\\\     0 & \\Delta t \\sigma_{v_y}^2 & 0 & \\sigma_{v_y}^2   \\end{bmatrix}_i \\end{equation} Notice fill compute Fiùê±i‚àí1F_i \\bm{x}_{- 1}, get back original equation xx yy, showing parameters indeed conform assume movement equation. Furthermore note WiW_i can obtained assuming error speed variables vxv_x vyv_y , similarly, working according movement equation denoted . measurement equation, define measurement matrix HH connects underlying latent movement model observations make. denoiser, assume measured positions without indication speeds, meaning measurement matrix HH reduce information : H=[10000100]\\begin{equation}   H = \\begin{bmatrix}     1 & 0 & 0 & 0 \\\\     0 & 1 & 0 & 0   \\end{bmatrix} \\end{equation} notice using measurement matrix previously computed values Fiùê±i‚àí1F_i \\bm{x}_{- 1}, automatically get back movement equation denoted terms xx yy. level measurement equation, also define measurement covariance matrix R, purposes defined : R=[œÉR200œÉR2]\\begin{equation}   R = \\begin{bmatrix}     \\sigma_R^2 & 0 \\\\     0 & \\sigma_R^2   \\end{bmatrix} \\end{equation} current specification, still several parameters need specified user. includes initial conditions ùê±0\\bm{x}_0 P0P_0, measurement variance œÉR2\\sigma_R^2, movement variances œÉvx2\\sigma_{v_x}^2 œÉvy2\\sigma_{v_y}^2. denoiser, specify broad though data-driven priors. Specifically, defined initial condition ùê±0\\bm{x}_0 vector mean x- y-positions alongside mean speeds x- y-direction. prior covariance matrix P0P_0 defined diagonal matrix observed variances variables ùê±0\\bm{x}_0. broad priors defined practical utility, may fit use-case. variances, require users specify assumed error variance œÉR2\\sigma_R^2 error argument (see later). Based provided error variance observed variances data, specify speed variances : œÉv2=œÉobs‚àí2E[Œît]2œÉR2\\begin{equation}   \\sigma_{v}^2 = \\sigma^\\text{obs} - \\frac{2}{E[\\Delta t]^2} \\sigma_R^2 \\end{equation} therefore dividing observed variance measurement error component (second part right-hand side) movement component (left-hand side). Note variances speeds computed dimensions separately.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"reality-vs-model","dir":"Articles","previous_headings":"Filters > Kalman filter > Kalman models","what":"Reality vs model","title":"Filtering data","text":"constant velocity model way, cautionary note warranted. mentioned , Kalman filter operates weighting observations predictions movement model. means predictions wrong, Kalman filter find useful information predictions best guess latent state ùê±\\bm{x} observations ùê≥\\bm{z}. means results Kalman filter sensitive specification Kalman model: predictions , allow us filter data sufficiently, similarly measurement specifications . words, useful carefully consider whether specified model fit use data obtained.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"binning","dir":"Articles","previous_headings":"Filters","what":"Binning","title":"Filtering data","text":"second filtering technique natively supported denoiser binning. Binning operates assumption certain position ùê±i\\bm{x}_i given time tit_i, may able aleviate noise contained within single observation averaging several observations within particular time interval. case, talking single position ùê±i\\bm{x}_i time tit_i anymore, rather average position ùê±‚Äæj\\bm{\\bar{x}}_j within bin jj ranging tj‚àí1t_{j - 1} tjt_j. Binning represents reduction data necessarily part previous endeavors, experimental data usually sampled 6Hz model operates 2Hz timescale. may prove useful researchers, also included package. Note, however, binning made optional explicitly called setting argument binning = TRUE.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"using-denoiser","dir":"Articles","previous_headings":"","what":"Using denoiser","title":"Filtering data","text":"mathematics way, can now focus use denoiser function filter one‚Äôs data. Throughout, use ‚Äúnoised ‚Äù dataset called data displays circular motion. Measured positions plane representing circular motion. Error added according independent measurement model. Now data created, can attempt filter data denoiser function. first step, interested applying Kalman filter data, call: Filtered positions achieved denoiser function. Several things note . First, provide value argument error, represents œÉR2\\sigma_R^2 constant velocity model. argument immediately provided constant_velocity function derive necessary parameters. Second, comparing noisy filtered data, one may see slight improvement, means definite one. may due several reasons. example, initial conditions may broad, allowing Kalman filter converge good weighting measurements predictions. specification measurement error may wrong, influencing weighting measurements predictions. finally, constant velocity model may wrong, assuming constant velocity x- y-direction may restrictive may therefore influence validity predictions. find correct, one play around specification parameters (see constant_velocity function).","code":"# Define the simulated angles of the observations angles <- seq(0, 2 * pi, length.out = 50)  # Define the dataset itself data <- data.frame(   time = 1:50,    x = 10 * cos(angles),   y = 10 * sin(angles) )  # Add noise to the data data <- noiser(   data,    model = \"independent\",   mean = c(0, 0),    covariance = diag(2) * 0.5 )  # Plot these data plot(data$x, data$y) # Add noise to the data denoised <- denoiser(   data,    model = \"constant_velocity\",   error = 0.5 )  # Plot the noised up data plot(denoised$x, denoised$y)"},{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"nonstandard-column-names-and-grouping","dir":"Articles","previous_headings":"Using denoiser","what":"Nonstandard column names and grouping","title":"Filtering data","text":"denoiser function works largely way noiser function, meaning functionality largely . applies nonstandard column names grouping well, details can found vignette Adding noise. Bringing practice, can combine pieces info follows:","code":"# Define the angles angles <- seq(0, 2 * pi, length.out = 50)  # Create data for two participants, each walking in a circle but a few meters away from each other data_1 <- data.frame(   seconds = 1:50,    X = 10 * cos(angles),   Y = 10 * sin(angles),   person = 1 ) data_2 <- data.frame(   seconds = 1:50,   X = 5 * cos(angles) + 5,   Y = 5 * sin(angles) + 5,   person = 2 ) data = rbind(data_1, data_2)  # Mention the additional columns explicitly in the mapping mapping <- c(   \"time\" = \"seconds\",   \"x\" = \"X\",   \"y\" = \"Y\" )  # Add noise to these data with the columns being provided data <- noiser(   data,    cols = mapping,   .by = \"person\",   model = \"independent\",   mean = c(0, 0),   covariance = diag(2) * 0.5 )  # Filter these data denoised <- denoiser(   data,    cols = mapping,   .by = \"person\",   model = \"constant_velocity\",   error = 0.5 ) head(denoised) ##   seconds         X          Y person ## 1       1  9.603610 -0.2709594      1 ## 2       2  9.800417  0.5828054      1 ## 3       3 10.398862  1.7091015      1 ## 4       4  9.880234  3.0982147      1 ## 5       5  8.283371  3.8024455      1 ## 6       6  7.458583  5.3335179      1"},{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"specifying-your-own-kalman-model","dir":"Articles","previous_headings":"Using denoiser","what":"Specifying your own Kalman model","title":"Filtering data","text":"denoiser function allows users specify Kalman model provide function argument model. specification use argument noiser , given specification model relatively complicated, refer interested reader vignette Adding noise information use argument. purposes, though, several things need taken account specifying Kalman models. First, function use data structure assumed within whole denoiser package. means time variable contained column time positions contained columns x y. need account grouping variable: handled hood. Second, function least take input data, can take arguments. using denoiser function, can specify value arguments next specification model: value given function provided model way value error examples handed constant_velocity function. Finally, function output named list containing values \"z\" (data smoothed), \"x\" \"P\" (initial conditions), \"F\", \"W\", \"B\" (parameters movement equation), \"u\" (values exogeneous variables), \"H\" \"R\" (parameters measurement equation). Kalman filter assumes values \"F\" \"W\" functions take single argument, namely time observations Œît\\Delta t (see equations ). furthermore also assumed data provided \"z\" contains columns x y (containing measured positions) delta_t (containing time since previous observation).","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/denoiser_vignette.html","id":"binning-the-data","dir":"Articles","previous_headings":"Using denoiser","what":"Binning the data","title":"Filtering data","text":"user wishes, can also bin data applying Kalman filter. can setting binned TRUE specifying certain range bins (span) given function apply data within bin (fx). example, assuming time specified seconds level, can bin together data span 5 seconds taking mean following way: Filtered binned positions achieved denoiser function. Note make sense time variable, one realize ‚àà{0,1,‚ãØT}\\\\{0, 1, \\cdots T\\}, define bins (ti,ti+Œît](t_i, t_i + \\Delta t] except first bin, defined [ti,ti+Œît][t_i, t_i + \\Delta t].","code":"denoised <- denoiser(   data,    cols = mapping,   .by = \"person\",   model = \"constant_velocity\",   error = 0.5,   binned = TRUE,   span = 5,   fx = mean ) head(denoised) ##   seconds          X         Y person ## 1     3.5   9.237513  2.375854      1 ## 2     9.0   5.140405  8.471663      1 ## 3    14.0  -0.642266  9.932376      1 ## 4    19.0  -6.550784  7.636946      1 ## 5    24.0 -10.127518  2.309825      1 ## 6    29.0  -8.830173 -4.431435      1 plot(   denoised$X,    denoised$Y,   col = factor(denoised$person) )"},{"path":"https://github.com/ndpvh/denoiser/articles/getting_started.html","id":"installing-and-using-the-package","dir":"Articles","previous_headings":"","what":"Installing and using the package","title":"Getting started","text":"install package, can use remotes package: load package, use library","code":"remotes::install_github(\"ndpvh/denoiser\") library(denoiser)"},{"path":"https://github.com/ndpvh/denoiser/articles/getting_started.html","id":"overview-of-the-package","dir":"Articles","previous_headings":"","what":"Overview of the package","title":"Getting started","text":"denoiser package introduced meet need systematic way add realistic noise simulated positional data , similarly, filter noise within type data. need arose within research group definition recovery studies Minds Mobile Agents pedestrian model data simulated predped package, package may apply broadly research goals. Note, however, current implementation relies heavily set calibration studies carried lab, results can found repository. package revolves around two primary functions. noiser function adds noise data provided user. Within package, refer function adds particular type noise ‚Äúmeasurement model‚Äù, reflecting define positional measurements relate actual positions. Natively, provide two measurement models: One assumes measurement error independent time one assume temporal component measurement error, defined extensively vignette Adding noise. However, also allow users specify measurement model , making package broadly applicable. denoiser function filters noise data provided user. default, filtering Kalman filter makes use internally refer ‚ÄúKalman model‚Äù. Currently, provide one model, namely constant velocity model, specification can find vignette Filtering data. Users can specify model, however, making package broadly applicable. Besides Kalman filter, package also natively supports binning one‚Äôs data, although doesn‚Äôt default. Finally, users can provide filters package, adding package‚Äôs usefulness.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/noiser_vignette.html","id":"measurement-model","dir":"Articles","previous_headings":"","what":"Measurement model","title":"Adding noise","text":"add noise (simulated) positional data, implicitly assume difference measurement position actual (latent) position. Within package, function connects measurement latent position called measurement model, can written : ùê≤=ùêü(ùê±)\\begin{equation}   \\mathbf{y} = \\mathbf{f}(\\mathbf{x}) \\end{equation} ùê≤\\mathbf{y} represents measurement latent position ùê±\\mathbf{x}. words, measurement depends equal latent position. exactly two relate depends link function ùêü\\mathbf{f}, two implemented package.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/noiser_vignette.html","id":"independent-error","dir":"Articles","previous_headings":"Measurement model","what":"Independent error","title":"Adding noise","text":"independent error, mean error added latent position () independent process (.e., independent value ùê±\\bm{x}) (b) independent time. One example measurement model case following. Denote ùê≤i\\bm{y}_i measurement taken time tit_i, furthermore denote ùê±i\\bm{x}_i latent position time, condition () met define relationship ùê≤i\\bm{y}_i ùê±i\\bm{x}_i : ùê≤i=ùê±i+ùõúi\\begin{equation}   \\bm{y}_i = \\bm{x}_i + \\bm{\\epsilon}_i \\end{equation} ùõú\\bm{\\epsilon} represents associated measurement error. Importantly condition (), ùõú\\bm{\\epsilon} independent ùê±\\bm{x}, meaning observation measurement ùê≤\\bm{y} can obtained simple adding error process, without interactions components. assumption conforms classical measurement theory perspective (Lord et al., 1968) assumed throughout. ‚Äôs left defined ùõú\\bm{\\epsilon}. Conforming condition (b), assume ùõú\\bm{\\epsilon} drawn multivariate normal distribution : ùõú‚àºiidN(ùõç,Œ£)\\begin{equation}   \\bm{\\epsilon} \\overset{iid}{\\sim} N(\\bm{\\mu}, \\Sigma) \\end{equation} ùõç\\bm{\\mu} represents mean error (e.g., case bias) Œ£\\Sigma covariance matrix error.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/noiser_vignette.html","id":"temporal-error","dir":"Articles","previous_headings":"Measurement model","what":"Temporal error","title":"Adding noise","text":"temporal error, mean error added latent position () independent process (b) depends time. means still conform previously defined relationship ùê≤\\bm{y} ùê±\\bm{x}, : ùê≤i=ùê±i+ùõúi\\begin{equation}   \\bm{y}_i = \\bm{x}_i + \\bm{\\epsilon}_i \\end{equation} However, model ùõú\\bm{\\epsilon} changes. Within package, assume error changes time vector autoregressive process, : ùõúi=ùõÖ+Œòùõúi‚àí1+ùõöi\\begin{equation}   \\bm{\\epsilon}_i = \\bm{\\delta} + \\Theta \\bm{\\epsilon}_{- 1} + \\bm{\\omega}_i \\end{equation} ùõúi\\bm{\\epsilon}_i represents measurement error time tit_i, ùõÖ\\bm{\\delta} intercept (measurement) process, Œò\\Theta transition matrix, defining linear temporal structure error, ùõöi\\bm{\\omega}_i innovation measurement process time tit_i (Hamilton, 1994). innovations distribution according multivariate normal distribution, : ùõö‚àºiidN(ùüé,Œ£)\\begin{equation}   \\bm{\\omega} \\overset{iid}{\\sim} N(\\bm{0}, \\Sigma) \\end{equation} Œ£\\Sigma covariance matrix innovations. specify parameters model, useful keep take first moments ùõú\\bm{\\epsilon} according vector autoregressive model account, especially one wishes relate independent error model. According vector autoregressive model, mean ùõç\\bm{\\mu} covariance Œ£œµ\\Sigma_\\epsilon ùõú\\bm{\\epsilon} equal : ùõç=(‚àíŒò)‚àí1ùõÖ\\begin{equation}   \\bm{\\mu} = (- \\Theta)^{-1} \\bm{\\delta} \\end{equation} Œ£œµ=Œ£‚àíŒòŒ£ŒòT\\begin{equation}   \\Sigma_\\epsilon = \\Sigma - \\Theta \\Sigma \\Theta^T  \\end{equation} II identity matrix.","code":""},{"path":"https://github.com/ndpvh/denoiser/articles/noiser_vignette.html","id":"using-noiser","dir":"Articles","previous_headings":"","what":"Using noiser","title":"Adding noise","text":"mathematics way, can now focus use noiser function achieve wanted results. First, generate dataset called data displaying circular motion. Latent positions plane representing circular motion. data created, can add noise noiser function. Using independent measurement model mean ùõç=[11]\\bm{\\mu} = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} Œ£=[10.250.251]\\Sigma = \\begin{bmatrix} 1 & 0.25 \\\\ 0.25 & 1 \\end{bmatrix} purpose can achieved calling following code: Measured positions plane representing circular motion. Error added according independent measurement model. Notice due specification ùõç\\bm{\\mu}, noisy data moved fall around new mean. Using temporal model can achieved similar way. Specifying ùõÖ=[2.52.5]\\bm{\\delta} = \\begin{bmatrix} 2.5 \\\\ 2.5 \\end{bmatrix}, Œò=[0.5000.5]\\Theta = \\begin{bmatrix} 0.5 & 0 \\\\ 0 & 0.5 \\end{bmatrix}, Œ£=[1.330.330.331.33]\\Sigma = \\begin{bmatrix} 1.33 & 0.33 \\\\ 0.33 & 1.33 \\end{bmatrix}, ùõç=[11]\\bm{\\mu} = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} Œ£œµ=[10.250.251]\\Sigma_\\epsilon = \\begin{bmatrix} 1 & 0.25 \\\\ 0.25 & 1 \\end{bmatrix}, write: Measured positions plane representing circular motion. Error added according temporal measurement model.","code":"# Define the simulated angles of the observations angles <- seq(0, 2 * pi, length.out = 50)  # Define the dataset itself data <- data.frame(   time = 1:50,    x = 10 * cos(angles),   y = 10 * sin(angles) )  # Plot these data plot(data$x, data$y) # Add noise to the data noised_up <- noiser(   data,    model = \"independent\",   mean = c(5, 5),   covariance = c(1, 0.25, 0.25, 1) |>     matrix(nrow = 2, ncol = 2) )  # Plot the noised up data plot(noised_up$x, noised_up$y) # Add noise to the data noised_up <- noiser(   data,    model = \"temporal\",   intercept = c(2.5, 2.5),   transition = diag(2) * 0.5,   covariance = c(4/3, 1/3, 1/3, 4/3) |>     matrix(nrow = 2, ncol = 2) )  # Plot the noised up data plot(noised_up$x, noised_up$y)"},{"path":"https://github.com/ndpvh/denoiser/articles/noiser_vignette.html","id":"things-to-look-out-for","dir":"Articles","previous_headings":"Using noiser","what":"Things to look out for","title":"Adding noise","text":"specifying parameters measurement models, several things look . First, one closely consider dimensionality parameters specifying . Specifically, denoiser package works assumption things measured/simulated two-dimensional plane, meaning data consist x- y-coordinate. parameters provided native independent temporal models cohere specification. means , independent model, mean consist exactly 2 values covariance consist 2√ó22 \\times 2 matrix. noiser can handle deviations specification mean, covariance: Similar restrictions parameters hold intercept, transition, covariance temporal model, transition covariance 2√ó22 \\times 2 matrices. Like independent measurement model, noiser robust misspecification dimension intercept, transition covariance. Second, specifying covariance matrix, one ensure positive definite. means () eigenvalues positive, (b) symmetric matrix, (c) reducable dimensionality (.e., leading minors positive). Examples non-positive-definite matrices following: easy way ensure covariance matrix positive definite specifying ‚Äôs Cholesky decomposition instead. Specifically, positive definite matrix can decomposed : Œ£=ŒìŒìT\\begin{equation}   \\Sigma = \\Gamma \\Gamma^T \\end{equation} dim(Œ£)=2√ó2\\text{dim}(\\Sigma) = 2 \\times 2, Œì\\Gamma : Œì=[Œ≥10Œ≥12Œ≥2]\\begin{equation}   \\Gamma = \\begin{bmatrix}     \\gamma_1 & 0 \\\\     \\gamma_{12} & \\gamma_{2}   \\end{bmatrix} \\end{equation} specifying matrix Œì\\Gamma instead Œ£\\Sigma, one therefore ensures noiser can run. Note, however, doesn‚Äôt ensure results make sense: user decide. example one can use Cholesky decomposition instead specifying Œ£\\Sigma directly: Measured positions plane representing circular motion. Error added according independent measurement model randomly generated covariance matrix Cholesky decomposition.","code":"# Specify only one mean: In this case, the value is used for both dimensions noised_up <- noiser(   data,    model = \"independent\",   mean = 5,   covariance = diag(2) ) head(noised_up) ##   time        x         y ## 1    1 15.83021  4.570620 ## 2    2 15.42149  7.639233 ## 3    3 15.86659  7.465688 ## 4    4 15.02089  8.480516 ## 5    5 12.25735  7.460495 ## 6    6 13.84274 11.046592 # Specify three means: In this case, only the first two values are used noised_up <- noiser(   data,    model = \"independent\",   mean = c(5, 10, 15),   covariance = diag(2) ) head(noised_up) ##   time        x         y ## 1    1 15.57895  9.643876 ## 2    2 15.06333 10.214307 ## 3    3 14.14649 13.613662 ## 4    4 12.53559 14.934246 ## 5    5 12.26453 15.105568 ## 6    6 11.49594 15.580700 # Specify a 1D matrix for the covariances: Leads to an error noised_up <- noiser(   data,    model = \"independent\",   mean = c(5, 5),   covariance = diag(1) ) ## Error in `measurement_models[[model]]()`: ## ! Provided covariance matrix does not have the right dimensionality. A 1 x 1 matrix is provided instead of the required 2 x 2 matrix. # Specify a 3D matrix for the covariances: Leads to an error noised_up <- noiser(   data,    model = \"independent\",   mean = c(5, 5),   covariance = diag(3) ) ## Error in `measurement_models[[model]]()`: ## ! Provided covariance matrix does not have the right dimensionality. A 3 x 3 matrix is provided instead of the required 2 x 2 matrix. # Negative eigenvalues noised_up <- noiser(   data,    model = \"independent\",   mean = c(0, 0),   covariance = diag(2) * (-1) ) ## Error in `MASS::mvrnorm()`: ## ! 'Sigma' is not positive definite # Negative eigenvalues noised_up <- noiser(   data,    model = \"independent\",   mean = c(0, 0),   covariance = c(1, 2, 2, 1) |>     matrix(nrow = 2, ncol = 2) ) ## Error in `MASS::mvrnorm()`: ## ! 'Sigma' is not positive definite # Reducable in dimension: Note that no error is thrown! noised_up <- noiser(   data,    model = \"independent\",   mean = c(0, 0),   covariance = c(1, 0, 0, 0) |>     matrix(nrow = 2, ncol = 2) ) # Define the lower-triangular Cholesky matrix based on random numbers. Maximal standard deviation/covariance of 1 gamma <- runif(3, min = 1e-2, max = 1) G <- c(gamma[1], gamma[2], 0, gamma[3]) |>   matrix(nrow = 2, ncol = 2)  # Create the covariance matrix S <- G %*% t(G)  # Use noiser to add noise to the data noised_up <- noiser(   data,    model = \"independent\",   mean = c(0, 0),   covariance = S )  # Plot the noised up data plot(noised_up$x, noised_up$y)"},{"path":"https://github.com/ndpvh/denoiser/articles/noiser_vignette.html","id":"nonstandard-column-names","dir":"Articles","previous_headings":"Using noiser","what":"Nonstandard column names","title":"Adding noise","text":"now, data consisted three columns, namely time, x, y. data structure expected functions denoiser package. data conform structure wish use noiser function, function automatically throw error: two ways around issue. First, one can change column names dataset manually conform requirements functions package. easy way around , also seems lazy end developer include robustness clear issue. agree conclusion. second way around issue therefore specify cols argument noiser. argument provides mapping column names used internally denoiser package column names originally present data named vector. Specifically, one can call: Note data contains additional columns, one specify cols argument.","code":"# Create data with nonstandard column names angles <- seq(0, 2 * pi, length.out = 50)  data <- data.frame(   seconds = 1:50,    X = 10 * cos(angles),   Y = 10 * sin(angles) )  # Add noise to these data with the defaults on noised_up <- noiser(data) ## Error in `[.data.frame`: ## ! undefined columns selected # Define the mapping of the columns mapping <- c(   \"time\" = \"seconds\",   \"x\" = \"X\",   \"y\" = \"Y\" )  # Add noise to the data through using the mapping noised_up <- noiser(   data,    cols = mapping ) head(noised_up) ##   seconds         X            Y ## 1       1 10.008332 -0.001464746 ## 2       2  9.934924  1.231661005 ## 3       3  9.680141  2.485432030 ## 4       4  9.272046  3.718075756 ## 5       5  8.686468  4.858085884 ## 6       6  7.976029  5.940597542 # Create data with nonstandard column names and additional variables angles <- seq(0, 2 * pi, length.out = 50)  data <- data.frame(   seconds = 1:50,    X = 10 * cos(angles),   Y = 10 * sin(angles),   variable_1 = 1:50,   variable_2 = rep(\"test\", 50) )  # Define the mapping of the columns mapping <- c(   \"time\" = \"seconds\",   \"x\" = \"X\",   \"y\" = \"Y\" )  # Add noise to these data with the columns being provided noised_up <- noiser(   data,    cols = mapping ) head(noised_up) ##   seconds        X           Y ## 1       1 9.989030 0.003668147 ## 2       2 9.920981 1.320289871 ## 3       3 9.689500 2.561860470 ## 4       4 9.290149 3.784864101 ## 5       5 8.725190 4.918384702 ## 6       6 8.027195 5.978526066 # Mention the additional columns explicitly in the mapping mapping <- c(   \"time\" = \"seconds\",   \"x\" = \"X\",   \"y\" = \"Y\",   \"v1\" = \"variable_1\",   \"v2\" = \"variable_2\" )  # Add noise to these data with the columns being provided noised_up <- noiser(   data,    cols = mapping ) head(noised_up) ##   seconds         X          Y variable_1 variable_2 ## 1       1 10.014854 0.01106708          1       test ## 2       2  9.903151 1.29462608          2       test ## 3       3  9.651743 2.55067656          3       test ## 4       4  9.254979 3.74998115          4       test ## 5       5  8.708365 4.92558443          5       test ## 6       6  8.012217 5.97988395          6       test"},{"path":"https://github.com/ndpvh/denoiser/articles/noiser_vignette.html","id":"grouping","dir":"Articles","previous_headings":"Using noiser","what":"Grouping","title":"Adding noise","text":"now, considered adding noise particular dataset one type movement. Imagine, however, dataset contains movement one individual, following case: Latent positions plane representing circular motion two different people. one wished add noise type data, one consider person generated data first place. ensure noiser generates noise accounting individual, one provide relevant column .argument, : Measured positions plane representing circular motion two different people adding noised person separately. Note don‚Äôt specify mapping person column specified .argument: automatically accounted hood.","code":"# Define the angles angles <- seq(0, 2 * pi, length.out = 50)  # Create data for two participants, each walking in a circle but a few meters away from each other data_1 <- data.frame(   seconds = 1:50,    X = 10 * cos(angles),   Y = 10 * sin(angles),   person = 1 ) data_2 <- data.frame(   seconds = 1:50,   X = 5 * cos(angles) + 5,   Y = 5 * sin(angles) + 5,   person = 2 ) data = rbind(data_1, data_2)  # Plot these data plot(   data$X,    data$Y,   col = factor(data$person) ) # Mention the additional columns explicitly in the mapping mapping <- c(   \"time\" = \"seconds\",   \"x\" = \"X\",   \"y\" = \"Y\" )  # Add noise to these data with the columns being provided noised_up <- noiser(   data,    cols = mapping,   .by = \"person\",   model = \"independent\",   mean = c(0, 0),   covariance = diag(2) * 0.5 )  # Plot the result plot(   noised_up$X,    noised_up$Y,   col = factor(noised_up$person) )"},{"path":"https://github.com/ndpvh/denoiser/articles/noiser_vignette.html","id":"specifying-your-own-measurement-model","dir":"Articles","previous_headings":"Using noiser","what":"Specifying your own measurement model","title":"Adding noise","text":"possible specify measurement model provide noiser noise data. Imagine, example, like create independent measurement model, one depends user-provided triangular matrix Œì\\Gamma rather covariance matrix Œ£\\Sigma, one can specifying: Measured positions plane representing circular motion two different people adding noised person separately measurement model. Several things note . First, my_model make use denoiser‚Äôs internal column names rather user-defined columns data. means time variable stored time x- y-coordinates stored x y respectively. Second, one worry .argument specifying my_model: handled automatically noiser. Finally, one can specify arguments my_model provide values arguments noiser . can seen chunk code, arguments mean cholesky my_model provided noiser rather my_model : noiser automatically provide arguments my_model unless otherwise specified. framework, users able specify measurement models please, allowing surpass provided package .","code":"# Create your own measurement model function my_model <- function(   data,    mean,    cholesky ) {   # Compute the covariance matrix   sigma <- cholesky %*% t(cholesky)    # Use mvrnorm to generate residuals   residuals <- MASS::mvrnorm(nrow(data), mu = mean, Sigma = sigma)    # Add the residuals to the data   data[, c(\"x\", \"y\")] <- data[, c(\"x\", \"y\")] + residuals    return(data) }  # Use noiser to add noise to the data noised_up <- noiser(   data,    cols = mapping,   .by = \"person\",   model = my_model,   mean = c(0, 0),   cholesky <- c(1, 0.25, 0, 1) |>     matrix(nrow = 2, ncol = 2) )  # Plot these data plot(   noised_up$X,    noised_up$Y,   col = factor(noised_up$person) )"},{"path":"https://github.com/ndpvh/denoiser/articles/noiser_vignette.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Adding noise","text":"Hamilton, J. D. (1994). Time series analysis. Princeton University Press. doi: 10.2307/j.ctv14jx6sm Lord, F. M., Novick, M. R., & Birnbaum, . (1968). Statistical theories mental test scores. Addison-Wesley.","code":""},{"path":"https://github.com/ndpvh/denoiser/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Niels Vanhasbroeck. Maintainer.","code":""},{"path":"https://github.com/ndpvh/denoiser/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"person, c) c= (2025). denoiser: Noising denoising spatial data. R package version 0.1.0, https://github.com/ndpvh/denoiser.","code":"@Manual{,   title = {denoiser: Noising and denoising spatial data},   author = {{person} and comment = c)},   year = {2025},   note = {R package version 0.1.0},   url = {https://github.com/ndpvh/denoiser}, }"},{"path":[]},{"path":"https://github.com/ndpvh/denoiser/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Noising and denoising spatial data","text":"package contains functions adding noise filtering noise positional data, data contains measurements x- y-coordinates. package implements code allows addition realistic noise simulated data user employ realistic filtering pipeline simulated empirical data, therefore allowing realistic recovery studies pedestrian modelers. Answers specific need Minds Mobile Agents pedestrian model implemented predped package, can broadly applied. implementation package defaults provided arguments functions heavily based results study conducted Dr.¬†Niels Vanhasbroeck Prof.¬†Dr.¬†Andrew Heathcote, repository can find .","code":""},{"path":[]},{"path":"https://github.com/ndpvh/denoiser/index.html","id":"installation","dir":"","previous_headings":"Getting started","what":"Installation","title":"Noising and denoising spatial data","text":"can install package Github command: installed, can load package library function.","code":"remotes::install_github(\"ndpvh/denoiser\") library(denoiser)"},{"path":"https://github.com/ndpvh/denoiser/index.html","id":"usage","dir":"","previous_headings":"Getting started","what":"Usage","title":"Noising and denoising spatial data","text":"primary functionality package provided two functions, namely noiser denoiser. Imagine data contains circular movement, following case: one can add ‚Äúrealistic‚Äù noise data using noiser function. Specifically, call: decrease noise , call denoiser function: details use functions, refer reader Documentation.","code":"# Create x- and y-coordinates for a person walking in a full circle angles <- seq(0, 2 * pi, length.out = 50) data <- data.frame(     time = 1:50,     x = 10 * cos(angles),     y = 10 * sin(angles) ) # Noise up the data noised_up <- noiser(     data,     # Arguments defining the noising ) # Denoise the data denoised <- denoiser(     noised_up,     # Arguments defining the denoising )"},{"path":"https://github.com/ndpvh/denoiser/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"Noising and denoising spatial data","text":"can find detailed documentation functions package well examples Documentation site. encounter bug, please file issue minimal working example Github.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/bin.html","id":null,"dir":"Reference","previous_headings":"","what":"Bin observations ‚Äî bin","title":"Bin observations ‚Äî bin","text":"Summarize observations within given time window, typically idea single observation per bin. Minds Mobile Agents model assumes pedestrians take walking decision every 0.5 seconds. function ensures data reflects assumption binning available data within time-frame. course, time window can adjusted user fit purposes.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/bin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bin observations ‚Äî bin","text":"","code":"bin(data, span = 0.5, fx = mean, cols = NULL, .by = NULL)"},{"path":"https://github.com/ndpvh/denoiser/reference/bin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bin observations ‚Äî bin","text":"data Dataframe contains information location (x- y-coordinates) time measurement taken. default, bin() assume information contained within columns \"x\", \"y\", \"time\" respectively. case, either change column names data specify cols argument. span Numeric denoting size bins. pertain values \"time\" variable. Defaults 0.5. fx Function execute data falls within bin. executed \"x\" \"y\" columns separately ouput single value. Defaults function mean(). cols Named vector named list containing relevant column names data contain prespecified column names \"time\", \"x\", \"y\". labels conform prespecified column names values given locations contain corresponding column names dataset. Defaults NULL, therefore assuming structure explained data. .String denoting whether moving window taken respect given grouping variable. Defaults NULL.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/bin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bin observations ‚Äî bin","text":"Binned dataframe similar structure data","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/bin.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bin observations ‚Äî bin","text":"Note variables required provided function, get lost translation. reason difficult implement meaningful aggregation across different types data user may supply.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/bin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bin observations ‚Äî bin","text":"","code":"# Generate data for illustration purposes data <- data.frame(   X = rnorm(100),   Y = rnorm(100),   seconds = rep(1:50, times = 2) / 10,   tag = rep(1:2, each = 50) )  # Bin the data together by taking the average for each second bin(   data,   span = 1,   fx = mean,   cols = c(     \"time\" = \"seconds\",     \"x\" = \"X\",     \"y\" = \"Y\"   ),   .by = \"tag\" ) #>    seconds           X           Y tag #> 1     0.60 -0.26711990 -0.59840370   1 #> 2     1.65 -0.10311363  0.50638281   1 #> 3     2.65 -0.09548419  0.16530901   1 #> 4     3.65 -0.01592759 -0.28837860   1 #> 5     4.60  0.28795196  0.53248461   1 #> 6     0.60  0.07446149  0.04194506   2 #> 7     1.65 -0.24860377 -0.42394017   2 #> 8     2.65  0.72176228  0.20049239   2 #> 9     3.65  0.06384934  0.77397261   2 #> 10    4.60  0.48828897  0.38153518   2"},{"path":"https://github.com/ndpvh/denoiser/reference/constant_velocity.html","id":null,"dir":"Reference","previous_headings":"","what":"Constant velocity model ‚Äî constant_velocity","title":"Constant velocity model ‚Äî constant_velocity","text":"model assumes movement occurs constant velocity, changes acceleration considered noise. previous study, found model performed reasonably well simulated observed pedestrian data.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/constant_velocity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constant velocity model ‚Äî constant_velocity","text":"","code":"constant_velocity(data, error = 0.031^2)"},{"path":"https://github.com/ndpvh/denoiser/reference/constant_velocity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constant velocity model ‚Äî constant_velocity","text":"data data.frame containing data base parameters constant velocity model. function assumes data.frame contains columns \"time\", \"x\", \"y\" containing time observed position (x, y) measured respectively. error Numeric numerical vector containing assumed value measurement error variance x- y-direction. consist either 1 2 values. 1 value provided, measurement error variance assumed dimensions. Defaults 0.031^2, value obtained experimentally.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/constant_velocity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constant velocity model ‚Äî constant_velocity","text":"Named list containing parameters relevant Kalman filter.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/constant_velocity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Constant velocity model ‚Äî constant_velocity","text":"constant velocity model based assumption velocity remains constant, acceleration can put 0. means can use following movement equation model changes positions, : $$\\begin{\\bmatrix}   x \\\\   y \\\\ \\end{bmatrix}_i = \\begin{\\bmatrix}   x \\\\   y \\\\ \\end{bmatrix}_{- 1} + \\begin{bmatrix}   v_x \\\\   v_y \\\\ \\end{bmatrix} \\Delta t$$ \\(x\\) \\(y\\) represent x- y-coordinates measurements time \\(t_i\\) \\(t_{- 1}\\) taken. variables \\(v_x\\) \\(v_y\\) represent speeds x- y-direction system moving, \\(\\Delta t = t_i - t_{- 1}\\) represents time two measurements. basic equation parameters Kalman filter derived. constant velocity model, keep track positional data respective velocities particular time point \\(t_i\\). means latent state \\(\\mathbf{x}\\) consists 4 values iteration, namely: $$\\mathbf{x}_i = \\begin{bmatrix}   x \\\\   y \\\\   v_x \\\\   v_y \\\\ \\end{bmatrix}_i$$ specification, define transition matrix \\(F\\) covariance matrix \\(W\\) movement equation follows: $$F_i = \\begin{bmatrix}   1 & 0 & \\Delta t & 0 \\\\   0 & 1 & 0 & \\Delta t \\\\   0 & 0 & 1 & 0 \\\\   0 & 0 & 0 & 1 \\\\ \\end{bmatrix}_i$$ $$W_i = \\begin{bmatrix}   \\Delta t^2 \\sigma_{v_x}^2 & 0 & \\Delta t \\sigma_{v_x}^2 & 0 \\\\   0 & \\Delta t^2 \\sigma_{v_y}^2 & 0 & \\Delta t \\sigma_{v_y}^2 \\\\   \\Delta t \\sigma_{v_x}^2 & 0 & \\sigma_{v_x}^2 & 0 \\\\   0 & \\Delta t \\sigma_{v_y}^2 & 0 & \\sigma_{v_y}^2 \\\\ \\end{bmatrix}_i$$ equations, \\(\\Delta t\\) represents time elapsed two observations, \\(\\Delta t = t_i - t_{- 1}\\). variances \\(\\sigma_{v_x}^2\\) \\(\\sigma_{v_y}^2\\) capture variation speeds \\(v_x\\) \\(v_y\\). Within function, estimate variances computing observed variance speeds subtracting assumed measurement error , x-direction, obtain: $$\\sigma_{v_x}^2 = VAR[v_x]^\\text{obs} - \\frac{2}{E[\\Delta t]^2} \\sigma_{\\epsilon, x}^2$$ \\(\\sigma_{\\epsilon, x}^2\\) \\(\\sigma_{\\epsilon, y}^2\\) provided error argument. Note assume covariance two dimensions movement covariance \\(W\\). Typically, movement equation also includes external forces may influence observed behavior. constant velocity model described function, assume parameters influence observed behavior, meaning set parameters \\(B\\) \\(\\mathbf{u}\\) 0. measurement equation, define measurement matrix \\(H\\) measurement error covariance matrix \\(R\\) : $$H = \\begin{bmatrix}   1 & 0 & 0 & 0 \\\\   0 & 1 & 0 & 0 \\\\ \\end{bmatrix}$$ $$R = \\begin{bmatrix}   \\sigma_\\epsilon^2 & 0 \\\\   0 & \\sigma_\\epsilon^2 \\end{bmatrix}$$ \\(\\sigma_\\epsilon^2\\) provided error argument. Importantly, matrix \\(R\\) transformed Cholesky decomposition, function kalman_filter assumes Cholesky decomposition provided stability purposes. Note two matrices time-independent: assumed constant iteration (long-term changes time) depend time obsevations \\(\\Delta t\\). Furthermore note measurement error covariance \\(R\\) can defined variables measurements , namely x- y-coordinates. error exists speeds \\(v_x\\) \\(v_y\\). Similarly, note measurement matrix \\(H\\) maps predictions latent level predictions measurement level, acknowledges measured x- y-coordinates. Finally, need define initial conditions Kalman filter starts. initial conditions taken observed initial locations speeds (\\(\\mathbf{x}_0\\)) observed variances variables (\\(P_0\\)). Note provide covariance matrix \\(P_0\\) diagonal simplicity.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/constant_velocity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constant velocity model ‚Äî constant_velocity","text":"","code":"# Generate data for illustration purposes. Movement in circular motion at a # pace of 1.27m/s with some added noise of SD = 10cm. # some added noise angles <- seq(0, 4 * pi, length.out = 100) coordinates <- 10 * cbind(cos(angles), sin(angles)) coordinates <- coordinates + rnorm(200, mean = 0, sd = 0.1)  data <- data.frame(   x = coordinates[, 1],   y = coordinates[, 2],   time = 1:100 )  # Generate the parameters of the Kalman filter according to the constant  # velocity model with an assumed measurement error variance of 0.01 constant_velocity(   data,    error = 0.1^2 ) #> $z #>               x            y time delta_t      delta_x      delta_y #> 1     9.9929143   0.10771165    1       0  0.000000000  0.000000000 #> 2     9.8923328   1.38408209    2       1 -0.100581497  1.276370439 #> 3     9.4348190   2.53131908    3       1 -0.457513749  1.147236989 #> 4     9.2902280   3.67658403    4       1 -0.144591017  1.145264950 #> 5     8.6286429   4.92358279    5       1 -0.661585114  1.246998757 #> 6     7.9893848   6.12649497    6       1 -0.639258123  1.202912176 #> 7     7.0309749   7.08925635    7       1 -0.958409822  0.962761382 #> 8     6.5704199   7.60260259    8       1 -0.460555062  0.513346241 #> 9     5.1569148   8.44326198    9       1 -1.413505036  0.840659395 #> 10    4.1200863   8.97937381   10       1 -1.036828495  0.536111824 #> 11    3.0478400   9.60493301   11       1 -1.072246332  0.625559206 #> 12    1.6094305   9.66614281   12       1 -1.438409545  0.061209792 #> 13    0.5300333  10.02800779   13       1 -1.079397152  0.361864984 #> 14   -0.7849890   9.97276117   14       1 -1.315022292 -0.055246619 #> 15   -1.9922152   9.90599088   15       1 -1.207226260 -0.066770290 #> 16   -3.2291390   9.42431607   16       1 -1.236923755 -0.481674810 #> 17   -4.5858961   8.85430413   17       1 -1.356757110 -0.570011936 #> 18   -5.4450800   8.34557627   18       1 -0.859183924 -0.508727866 #> 19   -6.5825009   7.62254910   19       1 -1.137420900 -0.723027168 #> 20   -7.4602019   6.70208134   20       1 -0.877700995 -0.920467760 #> 21   -8.2327454   5.81835187   21       1 -0.772543454 -0.883729469 #> 22   -8.8759244   4.58946779   22       1 -0.643179005 -1.228884083 #> 23   -9.4967695   3.63284589   23       1 -0.620845083 -0.956621900 #> 24   -9.6309589   2.05548564   24       1 -0.134189399 -1.577360249 #> 25   -9.9206768   0.99134928   25       1 -0.289717915 -1.064136354 #> 26  -10.0422357  -0.17788156   26       1 -0.121558895 -1.169230838 #> 27   -9.8035136  -1.54398613   27       1  0.238722091 -1.366104575 #> 28   -9.7478256  -2.75187054   28       1  0.055687973 -1.207884413 #> 29   -9.1373420  -3.90408981   29       1  0.610483568 -1.152219269 #> 30   -8.7111156  -5.33472943   30       1  0.426226483 -1.430639616 #> 31   -7.7858281  -6.06075130   31       1  0.925287468 -0.726021873 #> 32   -7.1710007  -7.14386972   32       1  0.614827368 -1.083118420 #> 33   -6.0489915  -7.92811543   33       1  1.122009185 -0.784245708 #> 34   -5.0639535  -8.53361998   34       1  0.985038058 -0.605504549 #> 35   -3.9479708  -9.33707727   35       1  1.115982646 -0.803457288 #> 36   -2.5972137  -9.75152697   36       1  1.350757164 -0.414449699 #> 37   -1.3078108  -9.88721508   37       1  1.289402864 -0.135688115 #> 38   -0.3273101  -9.91345074   38       1  0.980500691 -0.026235655 #> 39    1.0181005  -9.96181843   39       1  1.345410617 -0.048367695 #> 40    2.4893527  -9.50944683   40       1  1.471252221  0.452371604 #> 41    3.6788812  -9.35257054   41       1  1.189528465  0.156876287 #> 42    4.8430875  -8.95381834   42       1  1.164206341  0.398752200 #> 43    5.6574420  -8.25998860   43       1  0.814354486  0.693829743 #> 44    6.9233852  -7.17545621   44       1  1.265943184  1.084532385 #> 45    7.6607570  -6.43588346   45       1  0.737371824  0.739572753 #> 46    8.4047466  -5.45013630   46       1  0.743989621  0.985747162 #> 47    9.0734082  -4.30987063   47       1  0.668661560  1.140265668 #> 48    9.5136035  -3.04168817   48       1  0.440195262  1.268182460 #> 49    9.7362655  -1.95040697   49       1  0.222662080  1.091281202 #> 50    9.9295075  -0.64878189   50       1  0.193241927  1.301625083 #> 51    9.8605026   0.68688500   51       1 -0.069004827  1.335666881 #> 52    9.7441146   2.06587025   52       1 -0.116388006  1.378985259 #> 53    9.6462953   3.26520018   53       1 -0.097819323  1.199329924 #> 54    8.9464050   4.44976844   54       1 -0.699890288  1.184568257 #> 55    8.4415128   5.36800745   55       1 -0.504892255  0.918239013 #> 56    7.6124391   6.61058861   56       1 -0.829073692  1.242581165 #> 57    6.7246112   7.29076791   57       1 -0.887827903  0.680179297 #> 58    5.9465801   8.05918417   58       1 -0.778031066  0.768416255 #> 59    4.7376787   8.78015049   59       1 -1.208901431  0.720966320 #> 60    3.4255301   9.44776625   60       1 -1.312148577  0.667615762 #> 61    2.3565590   9.79942150   61       1 -1.068971083  0.351655255 #> 62    1.0871584  10.11873298   62       1 -1.269400628  0.319311477 #> 63   -0.2492937   9.98823441   63       1 -1.336452052 -0.130498573 #> 64   -1.6333636   9.99645976   64       1 -1.384069974  0.008225348 #> 65   -2.4754021   9.46709132   65       1 -0.842038460 -0.529368432 #> 66   -3.9602638   9.14034099   66       1 -1.484861750 -0.326750335 #> 67   -5.0102603   8.77030323   67       1 -1.049996463 -0.370037762 #> 68   -6.0321009   7.94023639   68       1 -1.021840611 -0.830066831 #> 69   -7.0086590   7.14482292   69       1 -0.976558074 -0.795413479 #> 70   -8.0782886   6.11174692   70       1 -1.069629563 -1.033075998 #> 71   -8.5916201   5.04072900   71       1 -0.513331596 -1.071017917 #> 72   -9.1498551   3.91176305   72       1 -0.558234949 -1.128965950 #> 73   -9.5941411   2.78346792   73       1 -0.444286021 -1.128295132 #> 74   -9.6866145   1.69524867   74       1 -0.092473383 -1.088219251 #> 75   -9.7790898   0.35778945   75       1 -0.092475269 -1.337459214 #> 76   -9.8837478  -0.99765268   76       1 -0.104658005 -1.355442136 #> 77   -9.6775995  -2.21643043   77       1  0.206148243 -1.218777747 #> 78   -9.4277473  -3.29753320   78       1  0.249852181 -1.081102768 #> 79   -8.7871543  -4.54897082   79       1  0.640593048 -1.251437620 #> 80   -8.3286710  -5.70530749   80       1  0.458483328 -1.156336667 #> 81   -7.3963065  -6.67754507   81       1  0.932364485 -0.972237589 #> 82   -6.5163591  -7.55401914   82       1  0.879947425 -0.876474063 #> 83   -5.5025332  -8.28708584   83       1  1.013825862 -0.733066707 #> 84   -4.3276826  -8.95785462   84       1  1.174850592 -0.670768776 #> 85   -3.3648294  -9.44924951   85       1  0.962853170 -0.491394889 #> 86   -2.0262829  -9.69494006   86       1  1.338546524 -0.245690550 #> 87   -0.6509583 -10.03702275   87       1  1.375324577 -0.342082695 #> 88    0.4374459  -9.95493324   88       1  1.088404193  0.082089513 #> 89    1.7190731  -9.88929130   89       1  1.281627286  0.065641940 #> 90    2.9470293  -9.45559630   90       1  1.227956162  0.433694999 #> 91    4.0531973  -8.91228828   91       1  1.106167956  0.543308022 #> 92    5.3203272  -8.56773627   92       1  1.267129945  0.344552014 #> 93    6.4659674  -7.76061361   93       1  1.145640201  0.807122654 #> 94    7.0858379  -6.69737113   94       1  0.619870524  1.063242486 #> 95    7.9111002  -6.06324790   95       1  0.825262256  0.634123229 #> 96    8.8261715  -4.74606944   96       1  0.915071319  1.317178455 #> 97    9.3460926  -3.73694545   97       1  0.519921068  1.009123990 #> 98    9.8907147  -2.54928273   98       1  0.544622171  1.187662725 #> 99    9.8839357  -1.09231343   99       1 -0.006779056  1.456969296 #> 100   9.8935536  -0.08452478  100       1  0.009617892  1.007788650 #>          speed_x      speed_y #> 1            NaN          NaN #> 2   -0.100581497  1.276370439 #> 3   -0.457513749  1.147236989 #> 4   -0.144591017  1.145264950 #> 5   -0.661585114  1.246998757 #> 6   -0.639258123  1.202912176 #> 7   -0.958409822  0.962761382 #> 8   -0.460555062  0.513346241 #> 9   -1.413505036  0.840659395 #> 10  -1.036828495  0.536111824 #> 11  -1.072246332  0.625559206 #> 12  -1.438409545  0.061209792 #> 13  -1.079397152  0.361864984 #> 14  -1.315022292 -0.055246619 #> 15  -1.207226260 -0.066770290 #> 16  -1.236923755 -0.481674810 #> 17  -1.356757110 -0.570011936 #> 18  -0.859183924 -0.508727866 #> 19  -1.137420900 -0.723027168 #> 20  -0.877700995 -0.920467760 #> 21  -0.772543454 -0.883729469 #> 22  -0.643179005 -1.228884083 #> 23  -0.620845083 -0.956621900 #> 24  -0.134189399 -1.577360249 #> 25  -0.289717915 -1.064136354 #> 26  -0.121558895 -1.169230838 #> 27   0.238722091 -1.366104575 #> 28   0.055687973 -1.207884413 #> 29   0.610483568 -1.152219269 #> 30   0.426226483 -1.430639616 #> 31   0.925287468 -0.726021873 #> 32   0.614827368 -1.083118420 #> 33   1.122009185 -0.784245708 #> 34   0.985038058 -0.605504549 #> 35   1.115982646 -0.803457288 #> 36   1.350757164 -0.414449699 #> 37   1.289402864 -0.135688115 #> 38   0.980500691 -0.026235655 #> 39   1.345410617 -0.048367695 #> 40   1.471252221  0.452371604 #> 41   1.189528465  0.156876287 #> 42   1.164206341  0.398752200 #> 43   0.814354486  0.693829743 #> 44   1.265943184  1.084532385 #> 45   0.737371824  0.739572753 #> 46   0.743989621  0.985747162 #> 47   0.668661560  1.140265668 #> 48   0.440195262  1.268182460 #> 49   0.222662080  1.091281202 #> 50   0.193241927  1.301625083 #> 51  -0.069004827  1.335666881 #> 52  -0.116388006  1.378985259 #> 53  -0.097819323  1.199329924 #> 54  -0.699890288  1.184568257 #> 55  -0.504892255  0.918239013 #> 56  -0.829073692  1.242581165 #> 57  -0.887827903  0.680179297 #> 58  -0.778031066  0.768416255 #> 59  -1.208901431  0.720966320 #> 60  -1.312148577  0.667615762 #> 61  -1.068971083  0.351655255 #> 62  -1.269400628  0.319311477 #> 63  -1.336452052 -0.130498573 #> 64  -1.384069974  0.008225348 #> 65  -0.842038460 -0.529368432 #> 66  -1.484861750 -0.326750335 #> 67  -1.049996463 -0.370037762 #> 68  -1.021840611 -0.830066831 #> 69  -0.976558074 -0.795413479 #> 70  -1.069629563 -1.033075998 #> 71  -0.513331596 -1.071017917 #> 72  -0.558234949 -1.128965950 #> 73  -0.444286021 -1.128295132 #> 74  -0.092473383 -1.088219251 #> 75  -0.092475269 -1.337459214 #> 76  -0.104658005 -1.355442136 #> 77   0.206148243 -1.218777747 #> 78   0.249852181 -1.081102768 #> 79   0.640593048 -1.251437620 #> 80   0.458483328 -1.156336667 #> 81   0.932364485 -0.972237589 #> 82   0.879947425 -0.876474063 #> 83   1.013825862 -0.733066707 #> 84   1.174850592 -0.670768776 #> 85   0.962853170 -0.491394889 #> 86   1.338546524 -0.245690550 #> 87   1.375324577 -0.342082695 #> 88   1.088404193  0.082089513 #> 89   1.281627286  0.065641940 #> 90   1.227956162  0.433694999 #> 91   1.106167956  0.543308022 #> 92   1.267129945  0.344552014 #> 93   1.145640201  0.807122654 #> 94   0.619870524  1.063242486 #> 95   0.825262256  0.634123229 #> 96   0.915071319  1.317178455 #> 97   0.519921068  1.009123990 #> 98   0.544622171  1.187662725 #> 99  -0.006779056  1.456969296 #> 100  0.009617892  1.007788650 #>  #> $x #>              [,1] #> [1,]  0.094643590 #> [2,]  0.021171338 #> [3,] -0.001003643 #> [4,] -0.001941782 #>  #> $P #>          [,1]     [,2]      [,3]      [,4] #> [1,] 50.85794  0.00000 0.0000000 0.0000000 #> [2,]  0.00000 49.99315 0.0000000 0.0000000 #> [3,]  0.00000  0.00000 0.8361181 0.0000000 #> [4,]  0.00000  0.00000 0.0000000 0.8296371 #>  #> $F #> function (delta_t)  #> { #>     M <- matrix(c(1, 0, delta_t, 0, 0, 1, 0, delta_t, 0, 0, 1,  #>         0, 0, 0, 0, 1), nrow = 4, ncol = 4, byrow = TRUE) #>     return(M) #> } #> <bytecode: 0x557508849d08> #> <environment: 0x55750884b410> #>  #> $W #> function (delta_t)  #> { #>     M <- matrix(c(delta_t^2 * var_x, 0, delta_t * var_x, 0, 0,  #>         delta_t^2 * var_y, 0, delta_t * var_y, delta_t * var_x,  #>         0, var_x, 0, 0, delta_t * var_y, 0, var_y), nrow = 4,  #>         ncol = 4, byrow = TRUE) #>     return(M) #> } #> <bytecode: 0x557508849250> #> <environment: 0x55750884b410> #>  #> $B #>      [,1] #> [1,]    0 #> [2,]    0 #> [3,]    0 #> [4,]    0 #>  #> $u #>        [,1] #>   [1,]    0 #>   [2,]    0 #>   [3,]    0 #>   [4,]    0 #>   [5,]    0 #>   [6,]    0 #>   [7,]    0 #>   [8,]    0 #>   [9,]    0 #>  [10,]    0 #>  [11,]    0 #>  [12,]    0 #>  [13,]    0 #>  [14,]    0 #>  [15,]    0 #>  [16,]    0 #>  [17,]    0 #>  [18,]    0 #>  [19,]    0 #>  [20,]    0 #>  [21,]    0 #>  [22,]    0 #>  [23,]    0 #>  [24,]    0 #>  [25,]    0 #>  [26,]    0 #>  [27,]    0 #>  [28,]    0 #>  [29,]    0 #>  [30,]    0 #>  [31,]    0 #>  [32,]    0 #>  [33,]    0 #>  [34,]    0 #>  [35,]    0 #>  [36,]    0 #>  [37,]    0 #>  [38,]    0 #>  [39,]    0 #>  [40,]    0 #>  [41,]    0 #>  [42,]    0 #>  [43,]    0 #>  [44,]    0 #>  [45,]    0 #>  [46,]    0 #>  [47,]    0 #>  [48,]    0 #>  [49,]    0 #>  [50,]    0 #>  [51,]    0 #>  [52,]    0 #>  [53,]    0 #>  [54,]    0 #>  [55,]    0 #>  [56,]    0 #>  [57,]    0 #>  [58,]    0 #>  [59,]    0 #>  [60,]    0 #>  [61,]    0 #>  [62,]    0 #>  [63,]    0 #>  [64,]    0 #>  [65,]    0 #>  [66,]    0 #>  [67,]    0 #>  [68,]    0 #>  [69,]    0 #>  [70,]    0 #>  [71,]    0 #>  [72,]    0 #>  [73,]    0 #>  [74,]    0 #>  [75,]    0 #>  [76,]    0 #>  [77,]    0 #>  [78,]    0 #>  [79,]    0 #>  [80,]    0 #>  [81,]    0 #>  [82,]    0 #>  [83,]    0 #>  [84,]    0 #>  [85,]    0 #>  [86,]    0 #>  [87,]    0 #>  [88,]    0 #>  [89,]    0 #>  [90,]    0 #>  [91,]    0 #>  [92,]    0 #>  [93,]    0 #>  [94,]    0 #>  [95,]    0 #>  [96,]    0 #>  [97,]    0 #>  [98,]    0 #>  [99,]    0 #> [100,]    0 #>  #> $H #>      [,1] [,2] [,3] [,4] #> [1,]    1    0    0    0 #> [2,]    0    1    0    0 #>  #> $R #>      [,1] [,2] #> [1,]  0.1  0.0 #> [2,]  0.0  0.1 #>"},{"path":"https://github.com/ndpvh/denoiser/reference/denoiser-function.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter the data ‚Äî denoiser","title":"Filter the data ‚Äî denoiser","text":"denoiser() function takes dataset attempts filter inherent measurement error. function makes use two steps: data go Kalman filter binned, according specifications user (see kalman_filter() bin()). Note first step mandatory left user whether also like bin data specifying argument binned.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/denoiser-function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter the data ‚Äî denoiser","text":"","code":"denoiser(   data,   cols = NULL,   .by = NULL,   binned = FALSE,   span = 0.5,   fx = mean,   ... )"},{"path":"https://github.com/ndpvh/denoiser/reference/denoiser-function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter the data ‚Äî denoiser","text":"data Dataframe contains information location (x- y-coordinates) time measurement taken. default, denoiser() assume information contained within columns \"x\", \"y\", \"time\" respectively. case, either change column names data specify cols argument. cols Named vector named list containing relevant column names data conform prespecified column names \"time\", \"x\", \"y\". labels conform prespecified column names values given locations contain corresponding column names dataset. Defaults NULL, therefore assuming structure explained data. .String denoting whether moving window taken respect given grouping variable. Defaults NULL. binned Logical denoting whether also bin data (TRUE) leave data unbinned (FALSE). Defaults FALSE. span Numeric denoting size bins. pertain values \"time\" variable. Defaults 0.5. Ignored binned FALSE. fx Function execute data falls within bin. executed \"x\" \"y\" columns separately ouput single value. Defaults function mean(). Ignored binned FALSE. ... Additional arguments defining Kalman filter employ filtering. See kalman_filter().","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/denoiser-function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter the data ‚Äî denoiser","text":"Smoothed /binned data.frame similar structure data","code":""},{"path":[]},{"path":"https://github.com/ndpvh/denoiser/reference/denoiser-function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter the data ‚Äî denoiser","text":"","code":"# Generate data for illustration purposes. Movement in circular motion at a # pace of 1.27m/s with some added noise of SD = 10cm. angles <- seq(0, 4 * pi, length.out = 100) coordinates <- 10 * cbind(cos(angles), sin(angles)) coordinates <- coordinates + rnorm(200, mean = 0, sd = 0.1)  data <- data.frame(   X = coordinates[, 1],   Y = coordinates[, 2],   seconds = rep(1:50, times = 2),   tag = rep(1:2, each = 50) )  # Use the denoiser function to get rid of the noise. Kalman filter is  # defined with the constant velocity model and an error variance of 0.01.  # Binning is performed with a span of 5 seconds and using the mean of the  # interval as representatitive of the position within that interval. denoiser(   data,   cols = c(     \"time\" = \"seconds\",     \"x\" = \"X\",     \"y\" = \"Y\"   ),   .by = \"tag\",   model = \"constant_velocity\",   error = 0.01,   binned = TRUE,   span = 5,   fx = mean ) #>    seconds          X         Y tag #> 1      3.5  9.2877399  3.068721   1 #> 2      9.0  5.1192208  8.402175   1 #> 3     14.0 -0.7479721  9.783390   1 #> 4     19.0 -6.4362481  7.461191   1 #> 5     24.0 -9.6951022  2.092571   1 #> 6     29.0 -8.9716957 -3.966425   1 #> 7     34.0 -4.9764325 -8.494692   1 #> 8     39.0  1.0090269 -9.708284   1 #> 9     44.0  6.6636493 -7.232362   1 #> 10    48.5  9.6249569 -2.503712   1 #> 11     3.5  9.0185592  3.648907   2 #> 12     9.0  4.6772568  8.664695   2 #> 13    14.0 -1.4158817  9.650819   2 #> 14    19.0 -6.9792837  6.935121   2 #> 15    24.0 -9.7608758  1.594803   2 #> 16    29.0 -8.7333699 -4.578267   2 #> 17    34.0 -4.2904950 -8.745307   2 #> 18    39.0  1.6268184 -9.691017   2 #> 19    44.0  7.0856512 -6.801369   2 #> 20    48.5  9.7624910 -1.889712   2"},{"path":"https://github.com/ndpvh/denoiser/reference/denoiser-package.html","id":null,"dir":"Reference","previous_headings":"","what":"denoiser: Noising and denoising spatial data ‚Äî denoiser-package","title":"denoiser: Noising and denoising spatial data ‚Äî denoiser-package","text":"Noiser denoiser functions used preprocessing spatial data. Based calibration project M4MA team.","code":""},{"path":[]},{"path":"https://github.com/ndpvh/denoiser/reference/finalize.html","id":null,"dir":"Reference","previous_headings":"","what":"Finalize data after analysis ‚Äî finalize","title":"Finalize data after analysis ‚Äî finalize","text":"Function used internally change data back original format conducting analysis, either binning (bin()) using Kalman filter (kalman_filter()). finalization consists renaming columns user-defined column names instead package- required ones deleting grouping variable originally present data.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/finalize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finalize data after analysis ‚Äî finalize","text":"","code":"finalize(data, cols = NULL, .by = NULL)"},{"path":"https://github.com/ndpvh/denoiser/reference/finalize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finalize data after analysis ‚Äî finalize","text":"data Dataframe contains information location (x- y-coordinates) time measurement taken. assumed information contained within columns \"x\", \"y\", \"time\" respectively. cols Named vector named list containing mapping original column names internal ones used within package. Defaults NULL, therefore assuming structure explained data. .String denoting whether moving window taken respect given grouping variable. Defaults NULL.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/finalize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finalize data after analysis ‚Äî finalize","text":"Adjusted data.frame","code":""},{"path":[]},{"path":"https://github.com/ndpvh/denoiser/reference/finalize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finalize data after analysis ‚Äî finalize","text":"","code":"# Generate data for illustration purposes # # Note that for this to work, I need to define the package-required column  # names data <- data.frame(   x = rnorm(100),   y = rnorm(100),   time = rep(1:50, times = 2) / 10,   id = rep(1:2, each = 50) )  # Prepare the data for analysis finalize(   data,   cols = c(     \"time\" = \"seconds\",     \"x\" = \"X\",     \"y\" = \"Y\"   ),   .by = \"tag\" ) #>     seconds            X           Y #> 1       0.1 -0.506286298 -0.52079637 #> 2       0.2 -1.109968853 -0.63901860 #> 3       0.3 -0.948705723 -0.63589414 #> 4       0.4  0.476843757  0.10658698 #> 5       0.5 -0.795201560  1.17691425 #> 6       0.6  0.234326923  0.44739115 #> 7       0.7 -1.222451097  2.27295477 #> 8       0.8 -2.453647354  0.13605821 #> 9       0.9 -1.489260814 -1.99903913 #> 10      1.0 -0.432147734 -0.42050087 #> 11      1.1 -0.942554006 -0.37840740 #> 12      1.2 -0.121450799  1.22077479 #> 13      1.3  1.336446798 -1.54103029 #> 14      1.4 -0.860356182 -0.31031012 #> 15      1.5  0.666537820 -0.02010818 #> 16      1.6 -1.421534746 -2.39020034 #> 17      1.7  1.170056168  0.88986536 #> 18      1.8 -1.404714543 -1.48281332 #> 19      1.9  1.101708096  0.44575035 #> 20      2.0  0.697986263  1.36977586 #> 21      2.1 -0.864349803 -0.02011003 #> 22      2.2 -1.091470351 -0.10921759 #> 23      2.3 -0.037051465  0.26466174 #> 24      2.4  0.810053792  0.30384826 #> 25      2.5 -0.499355412 -0.18338848 #> 26      2.6  0.948031588  0.55964967 #> 27      2.7 -0.174245957 -0.18655384 #> 28      2.8 -1.106235952 -0.81227537 #> 29      2.9 -0.945985005 -1.64058167 #> 30      3.0  0.289089591  0.50792248 #> 31      3.1  0.876913145  1.75433696 #> 32      3.2 -1.148903940  0.59240020 #> 33      3.3 -1.137612756  1.01671329 #> 34      3.4 -1.437246735  0.12162059 #> 35      3.5 -0.494143476 -1.07806726 #> 36      3.6  0.840801808 -1.14356572 #> 37      3.7  0.791534124 -0.52964368 #> 38      3.8 -0.168848948 -0.68127316 #> 39      3.9  0.612722104 -0.20244756 #> 40      4.0 -0.771158924  1.68449572 #> 41      4.1  0.888628993 -1.03377324 #> 42      4.2  0.013214477 -0.15597667 #> 43      4.3  0.225339515 -0.04640064 #> 44      4.4 -0.729915210 -0.95362873 #> 45      4.5 -1.222487070  0.41626080 #> 46      4.6  0.406805171  0.11402961 #> 47      4.7 -0.751012223  0.06391875 #> 48      4.8 -0.162116540 -0.91933224 #> 49      4.9  0.352010126  0.90133529 #> 50      5.0 -0.289058300 -0.79772830 #> 51      0.1  0.104662227  0.66822120 #> 52      0.2  0.720186531  0.15521430 #> 53      0.3 -0.611046082  0.12868809 #> 54      0.4 -1.106914072 -1.53306545 #> 55      0.5  0.534803326  0.20236067 #> 56      0.6  0.736067968 -0.71753865 #> 57      0.7 -1.222501574  0.36169476 #> 58      0.8  1.021415310  1.39900429 #> 59      0.9  0.465165158  0.37269896 #> 60      1.0  0.790472705 -1.56564429 #> 61      1.1 -0.130264801 -0.05169454 #> 62      1.2 -0.930285334  0.51408210 #> 63      1.3 -0.364851004  0.54989952 #> 64      1.4  0.153872493  0.86781691 #> 65      1.5  0.413154818  0.68436008 #> 66      1.6  2.480823360 -0.16267998 #> 67      1.7 -2.179956742 -1.78436472 #> 68      1.8  0.420874578 -1.03714557 #> 69      1.9 -0.357528325  0.83014772 #> 70      2.0 -0.646861514  0.60734694 #> 71      2.1 -0.050141801 -0.12218636 #> 72      2.2  0.416942847  0.93312514 #> 73      2.3 -0.632587542 -0.96127668 #> 74      2.4  1.150146673  0.25508171 #> 75      2.5 -0.235475907 -0.54540157 #> 76      2.6 -1.643107386  0.93036074 #> 77      2.7 -1.503382146 -0.53765056 #> 78      2.8 -2.050584847 -0.45242607 #> 79      2.9 -0.753198229 -0.43929097 #> 80      3.0 -0.134141958 -0.61622311 #> 81      3.1  1.005782847  0.44163455 #> 82      3.2  2.167186798  0.48259745 #> 83      3.3  2.322556540  0.54214438 #> 84      3.4 -1.020423391 -2.29078465 #> 85      3.5  0.048814436  0.31035185 #> 86      3.6 -0.771888628  1.40407898 #> 87      3.7 -0.785235068  1.37711764 #> 88      3.8 -0.726603031  1.06039565 #> 89      3.9  0.681878032  0.63217289 #> 90      4.0 -0.229843287  1.08492804 #> 91      4.1 -1.510601724  1.35645944 #> 92      4.2 -0.583727687  0.36242404 #> 93      4.3 -2.022918454  2.16934446 #> 94      4.4  0.403504676  0.13913051 #> 95      4.5  0.550015549  1.37632653 #> 96      4.6  0.028357122 -0.49144999 #> 97      4.7  0.893165020  1.53491576 #> 98      4.8 -0.376555496 -0.41619872 #> 99      4.9  0.605884808 -0.52054380 #> 100     5.0 -0.004874726  0.85058387"},{"path":"https://github.com/ndpvh/denoiser/reference/independent.html","id":null,"dir":"Reference","previous_headings":"","what":"Add independent error to data ‚Äî independent","title":"Add independent error to data ‚Äî independent","text":"Error generated multivariate normal distribution mean covariance specified user. Primary assumption model errors independent time, stands contrast temporal() model.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/independent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add independent error to data ‚Äî independent","text":"","code":"independent(   data,   mean = c(0, 0),   covariance = matrix(c(0.031^2, 0, 0, 0.027^2), nrow = 2, ncol = 2) )"},{"path":"https://github.com/ndpvh/denoiser/reference/independent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add independent error to data ‚Äî independent","text":"data data.frame containing data base parameters constant velocity model. function assumes data.frame contains columns \"time\", \"x\", \"y\" containing time observed position (x, y) measured respectively. mean Numeric vector 1 2 values containing mean error process. 1 number provided, value assumed represent mean x- y-dimensions. Defaults c(0, 0), representing bias system. covariance Numeric matrix dimensionality \\(2 \\times 2\\), variances errors x y diagonal covariance errors -diagonal. Defaults variances x- y-dimension equal 0.031^2 0.027^2 respectively, covariance equal 0.02. values represent means respective variances covariances found across four days calibration study informed project.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/independent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add independent error to data ‚Äî independent","text":"data.frame \"x\" \"y\" columns additional noise .","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/independent.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add independent error to data ‚Äî independent","text":"According function, observed positions \\(\\mathbf{y}_i\\) time \\(t_i\\) contain white noise error. symbols, comes saying : $$\\mathbf{\\epsilon}_{} \\sim N(\\mathbf{\\mu}, \\Sigma)$$ \\(\\mathbf{\\mu}\\) represents mean noise \\(\\Sigma\\) covariance matrix noise. observed positions \\(\\mathbf{y}_i\\) consist systematic component (.e., latent positions, provided data) unsystematic error component : $$\\mathbf{y}_i = \\mathbf{x}_i + \\mathbf{\\epsilon}_i$$","code":""},{"path":[]},{"path":"https://github.com/ndpvh/denoiser/reference/independent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add independent error to data ‚Äî independent","text":"","code":"# Generate data for illustration purposes. Movement in circular motion at a # pace of 1.27m/s with some added noise of SD = 10cm. angles <- seq(0, 4 * pi, length.out = 100) coordinates <- 10 * cbind(cos(angles), sin(angles))  data <- data.frame(   x = coordinates[, 1],   y = coordinates[, 2],   time = 1:100 )  # Add independent noise to these data with an error variance of 0.01 in each # dimension independent(   data,   mean = c(0, 0),   covariance = diag(2) * 0.01 ) |>   head() #>          x           y time #> 1 9.919688 -0.08293518    1 #> 2 9.961128  1.24405494    2 #> 3 9.558238  2.35697150    3 #> 4 9.159643  3.73994753    4 #> 5 8.669926  4.86507433    5 #> 6 8.055382  5.96486586    6"},{"path":"https://github.com/ndpvh/denoiser/reference/kalman_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Smooth using a Kalman filter ‚Äî kalman_filter","title":"Smooth using a Kalman filter ‚Äî kalman_filter","text":"higher-level function first look whether data needs processed given variable. run Kalman filter grouped data.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/kalman_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smooth using a Kalman filter ‚Äî kalman_filter","text":"","code":"kalman_filter(   data,   model = \"constant_velocity\",   cols = NULL,   .by = NULL,   N_min = 5,   ... )"},{"path":"https://github.com/ndpvh/denoiser/reference/kalman_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smooth using a Kalman filter ‚Äî kalman_filter","text":"data Dataframe contains information location (x- y-coordinates) time measurement taken. default, kalman_filter() assume information contained within columns \"x\", \"y\", \"time\" respectively. case, either change column names data specify cols argument. model String denoting model use. Defaults \"constant_velocity\", currently one implemented. cols Named vector named list containing relevant column names data contain prespecified column names \"time\", \"x\", \"y\". labels conform prespecified column names values given locations contain corresponding column names dataset. Defaults NULL, therefore assuming structure explained data. .String denoting whether moving window taken respect given grouping variable. Defaults NULL. N_min Integer denoting minimum number datapoints needed use Kalman filter. Defaults 5. ... Additional arguments provided loaded model. information, see constant_velocity().","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/kalman_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Smooth using a Kalman filter ‚Äî kalman_filter","text":"Smoothed dataframe similar structure data","code":""},{"path":[]},{"path":"https://github.com/ndpvh/denoiser/reference/kalman_filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Smooth using a Kalman filter ‚Äî kalman_filter","text":"","code":"# Generate data for illustration purposes. Movement in circular motion at a # pace of 1.27m/s with some added noise of SD = 10cm. angles <- seq(0, 4 * pi, length.out = 100) coordinates <- 10 * cbind(cos(angles), sin(angles)) coordinates <- coordinates + rnorm(200, mean = 0, sd = 0.1)  data <- data.frame(   X = coordinates[, 1],   Y = coordinates[, 2],   seconds = rep(1:50, times = 2),   tag = rep(1:2, each = 50) )  # Use the Kalman filter with the constant velocity model on these data to  # filter out the measurement error. Provide an assumed variance of 0.01  # to this model kalman_filter(   data,   model = \"constant_velocity\",   cols = c(     \"time\" = \"seconds\",     \"x\" = \"X\",     \"y\" = \"Y\"   ),   .by = \"tag\",   error = 0.01 ) #>     seconds            X            Y tag #> 1         1  10.00846039  -0.19019709   1 #> 2         2   9.85010147   1.24783407   1 #> 3         3   9.82770626   2.51657614   1 #> 4         4   9.25952296   3.76305095   1 #> 5         5   8.60195480   5.00022084   1 #> 6         6   8.13884984   5.89140457   1 #> 7         7   7.30857891   6.96685892   1 #> 8         8   6.42917395   7.72363884   1 #> 9         9   5.43807644   8.44589693   1 #> 10       10   4.13935796   9.02951960   1 #> 11       11   2.83145888   9.46222533   1 #> 12       12   1.85777338   9.85351616   1 #> 13       13   0.29476430  10.00993632   1 #> 14       14  -0.83413336   9.91067676   1 #> 15       15  -2.25777446   9.71607546   1 #> 16       16  -3.24180601   9.71927876   1 #> 17       17  -4.59407509   8.83612014   1 #> 18       18  -5.56306943   8.25782563   1 #> 19       19  -6.45803052   7.46662014   1 #> 20       20  -7.34489277   6.59179407   1 #> 21       21  -8.09305360   5.70788359   1 #> 22       22  -9.05134535   4.62015031   1 #> 23       23  -9.67681807   3.32424302   1 #> 24       24  -9.73435337   2.22240601   1 #> 25       25  -9.85172994   0.94452340   1 #> 26       26 -10.05984798  -0.45804127   1 #> 27       27  -9.91695847  -1.47360697   1 #> 28       28  -9.62099443  -2.70707615   1 #> 29       29  -9.14114097  -4.05199754   1 #> 30       30  -8.72724534  -5.21662982   1 #> 31       31  -7.79390962  -6.36369619   1 #> 32       32  -7.24825350  -7.24243455   1 #> 33       33  -6.06968803  -7.85469322   1 #> 34       34  -5.04538488  -8.80432272   1 #> 35       35  -3.89291457  -9.38287200   1 #> 36       36  -2.60877190  -9.56531012   1 #> 37       37  -1.44242000  -9.79097840   1 #> 38       38  -0.13671592 -10.01708621   1 #> 39       39   1.11996410  -9.78778607   1 #> 40       40   2.38492754  -9.73750286   1 #> 41       41   3.72549894  -9.25336037   1 #> 42       42   4.78266757  -8.77351388   1 #> 43       43   5.79518211  -8.27397135   1 #> 44       44   6.77056712  -7.42813277   1 #> 45       45   7.68772805  -6.65474234   1 #> 46       46   8.46694739  -5.42427628   1 #> 47       47   8.97442853  -4.15371191   1 #> 48       48   9.59373734  -3.26029519   1 #> 49       49   9.75380815  -1.75274441   1 #> 50       50   9.85312616  -0.70346623   1 #> 51        1  10.05126177   0.60369621   2 #> 52        2   9.77885533   1.91838735   2 #> 53        3   9.47554283   3.06145685   2 #> 54        4   8.99437344   4.26771187   2 #> 55        5   8.53359338   5.39385684   2 #> 56        6   7.62104412   6.50949509   2 #> 57        7   6.89693115   7.32209922   2 #> 58        8   5.82355019   8.35921421   2 #> 59        9   4.58800389   8.92900460   2 #> 60       10   3.43812030   9.41687410   2 #> 61       11   2.14548302   9.60083460   2 #> 62       12   1.09603021   9.96913341   2 #> 63       13  -0.08774125   9.94972035   2 #> 64       14  -1.46833544  10.02561581   2 #> 65       15  -2.49243070   9.64650443   2 #> 66       16  -3.65933096   9.18503485   2 #> 67       17  -4.95573053   8.59229460   2 #> 68       18  -6.11427970   7.81060885   2 #> 69       19  -7.10013148   7.26867045   2 #> 70       20  -7.82373334   6.15339512   2 #> 71       21  -8.72533011   5.13182042   2 #> 72       22  -9.20538140   4.13367937   2 #> 73       23  -9.60897564   2.68781744   2 #> 74       24 -10.07366486   1.51955869   2 #> 75       25 -10.09953632   0.24780032   2 #> 76       26  -9.91521017  -1.13500388   2 #> 77       27  -9.76030496  -2.23105796   2 #> 78       28  -9.40718840  -3.45239536   2 #> 79       29  -8.89346028  -4.60792619   2 #> 80       30  -8.30950471  -5.62623442   2 #> 81       31  -7.56613314  -6.71294954   2 #> 82       32  -6.62888104  -7.55439520   2 #> 83       33  -5.71666166  -8.39997287   2 #> 84       34  -4.48705556  -9.17707980   2 #> 85       35  -3.47142796  -9.47876126   2 #> 86       36  -1.78061990  -9.70155972   2 #> 87       37  -0.63509818 -10.06431696   2 #> 88       38   0.47970186 -10.04429728   2 #> 89       39   1.80814107  -9.94147224   2 #> 90       40   2.84538229  -9.70007570   2 #> 91       41   4.13499479  -9.11686444   2 #> 92       42   5.21349980  -8.34132206   2 #> 93       43   6.42920609  -7.65898807   2 #> 94       44   7.26664264  -7.01497622   2 #> 95       45   7.88473508  -6.02402791   2 #> 96       46   8.65132057  -4.55659584   2 #> 97       47   9.27082631  -3.81538542   2 #> 98       48   9.64981530  -2.58688901   2 #> 99       49   9.90377589  -1.28671097   2 #> 100      50   9.87959142   0.07365152   2"},{"path":"https://github.com/ndpvh/denoiser/reference/kalman_models.html","id":null,"dir":"Reference","previous_headings":"","what":"List of Kalman filter models ‚Äî kalman_models","title":"List of Kalman filter models ‚Äî kalman_models","text":"List Kalman filter models","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/kalman_models.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List of Kalman filter models ‚Äî kalman_models","text":"","code":"kalman_models"},{"path":"https://github.com/ndpvh/denoiser/reference/kalman_models.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"List of Kalman filter models ‚Äî kalman_models","text":"object class list length 1.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/kf_innovation.html","id":null,"dir":"Reference","previous_headings":"","what":"Innovation step in the Kalman filter ‚Äî kf_innovation","title":"Innovation step in the Kalman filter ‚Äî kf_innovation","text":"Innovation step Kalman filter","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/kf_innovation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Innovation step in the Kalman filter ‚Äî kf_innovation","text":"","code":"kf_innovation(z, x, P, H, R)"},{"path":"https://github.com/ndpvh/denoiser/reference/kf_innovation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Innovation step in the Kalman filter ‚Äî kf_innovation","text":"z Vector measured values time t + 1 x Vector predicted values movement equation time t + 1. P Cholesky decomposition estimation covariance matrix time t + 1. H Matrix relating values x values y. R Cholesky decomposition measurement noise covariance matrix.#'","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/kf_innovation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Innovation step in the Kalman filter ‚Äî kf_innovation","text":"Named list innovation (\"y\"), Cholesky decomposition covariance matrix (\"S\"), Kalman gain (\"K\")","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/kf_innovation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Innovation step in the Kalman filter ‚Äî kf_innovation","text":"innovation step, compute much error expect measurement movement equation correct prediction. expected \"innovation\" defined : $$\\mathbf{y}_i = \\mathbf{z}_i - H \\mathbf{x}_i$$ \\(\\mathbf{z}\\) measurement, \\(H\\) measurement matrix, \\(\\mathbf{x}\\) prediction obtained prediction step. also compute covariance matrix innovation, defined : $$\\Sigma_i = H P_i H^T + R$$ \\(R\\) contains (assumed) measurement covariances. interesting note value \\(\\Sigma\\) always symmetric value \\(H\\). Whether Cholesky decomposition exists, however, depend \\(H\\) \\(P\\). final step, compute Kalman gain using covariance prediction total covariance measurement process following equation: $$K_i = P_i H^T \\Sigma_i^{-1}$$ one may notice, Kalman gain measure much can trust prediction, specifically putting prediction covariance total variance. thus related measure reliability.","code":""},{"path":[]},{"path":"https://github.com/ndpvh/denoiser/reference/kf_predict.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction step in the Kalman filter ‚Äî kf_predict","title":"Prediction step in the Kalman filter ‚Äî kf_predict","text":"Prediction step Kalman filter","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/kf_predict.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction step in the Kalman filter ‚Äî kf_predict","text":"","code":"kf_predict(   x0,   P0,   F,   W,   u = matrix(0, nrow = length(x0), ncol = 1),   B = matrix(0, nrow = length(u), ncol = length(u)) )"},{"path":"https://github.com/ndpvh/denoiser/reference/kf_predict.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction step in the Kalman filter ‚Äî kf_predict","text":"x0 Vector values movement equation time t. P0 Cholesky decomposition covariance x0 time t. F Transition matrix, relating values X time t t. W Cholesky decomposition process noise covariance matrix. u Vector values external variables time t. default empty vector. B Matrix connects external variables u values x. default empty matrix.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/kf_predict.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction step in the Kalman filter ‚Äî kf_predict","text":"Named list predicted values \\(\\mathbf{x}\\) (\"x\") \\(P\\) (\"P\") next time point.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/kf_predict.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prediction step in the Kalman filter ‚Äî kf_predict","text":"step, use movement equation predict new values x based initial condition defined location \\(\\mathbf{x}\\) covariance \\(P\\) time \\(t_{- 1}\\), using equation: $$\\mathbf{x}_t = F_i \\mathbf{x}_{- 1} + B_i \\mathbf{u}_i + \\mathbf{\\epsilon}_i$$ \\(F\\) movement transition matrix, \\(B\\) scales external influences \\(\\mathbf{u}\\), \\(\\mathbf{\\epsilon}\\) defines error, terms defined time point \\(t_i\\). covariance \\(P\\) also updated based equation, representing certainty around prediction \\(\\mathbf{x}_i\\). covariance updated following equation: $$P_i = F_i P_{- 1} F_i^T + W_i$$ \\(W\\) represents covariance matrix \\(\\epsilon\\). stability purposes, use Cholesky decompositions covariance matrices rather actual covariance matrices. needs taken account making model.","code":""},{"path":[]},{"path":"https://github.com/ndpvh/denoiser/reference/kf_update.html","id":null,"dir":"Reference","previous_headings":"","what":"Updating step in the Kalman filter ‚Äî kf_update","title":"Updating step in the Kalman filter ‚Äî kf_update","text":"Updating step Kalman filter","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/kf_update.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Updating step in the Kalman filter ‚Äî kf_update","text":"","code":"kf_update(x, P, y, H, K)"},{"path":"https://github.com/ndpvh/denoiser/reference/kf_update.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Updating step in the Kalman filter ‚Äî kf_update","text":"x Vector predicted values movement equation time t + 1. P Cholesky decomposition estimation covariance matrix time t + 1. y Vector innovations time t + 1 H Measurement matrix connecting measurement movement. K Kalman gain","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/kf_update.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Updating step in the Kalman filter ‚Äî kf_update","text":"List containing smoothed value \\(x\\) (\"x\") together Cholesky decomposition covariance (\"P\")","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/kf_update.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Updating step in the Kalman filter ‚Äî kf_update","text":"update step, use measurement innovation \\(\\mathbf{y}_i\\) predicted value \\(\\mathbf{x}_i\\) combine guess latent state system . , use following equation: $$\\hat{\\mathbf{x}}_i = \\mathbf{x}_i + K \\mathbf{y}$$ \\(\\mathbf{x}\\) prediction coming prediction step, \\(\\mathbf{y}\\) innovation derived innovation step, \\(K\\) Kalman gain, \\(\\hat{\\mathbf{x}}\\) latent state system. also compute covariance update: $$\\hat{P}_i = (- K H) P_i$$ identity matrix, \\(H\\) measurement matrix, \\(K\\) Kalman gain, \\(P_i\\) covariance prediction derived prediction step, \\(\\hat{P}_i\\) estimated certainty around guess \\(\\hat{\\mathbf{x}}_i\\). Note values \\(\\hat{\\mathbf{x}}_i\\) \\(\\hat{P}_i\\) used initial conditions next time step \\(t_{+ 1}\\), therefore serving input prediction step starting cycle .","code":""},{"path":[]},{"path":"https://github.com/ndpvh/denoiser/reference/measurement_models.html","id":null,"dir":"Reference","previous_headings":"","what":"List of measurement models ‚Äî measurement_models","title":"List of measurement models ‚Äî measurement_models","text":"List measurement models","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/measurement_models.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List of measurement models ‚Äî measurement_models","text":"","code":"measurement_models"},{"path":"https://github.com/ndpvh/denoiser/reference/measurement_models.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"List of measurement models ‚Äî measurement_models","text":"object class list length 2.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/noiser.html","id":null,"dir":"Reference","previous_headings":"","what":"Add noise to the data ‚Äî noiser","title":"Add noise to the data ‚Äî noiser","text":"noiser() function takes dataset adds measurement error . , currently makes use one two potential measurement models: One measurement error independent time (independent()) one measurement error depend time (temporal()).","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/noiser.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add noise to the data ‚Äî noiser","text":"","code":"noiser(data, cols = NULL, .by = NULL, model = \"temporal\", ...)"},{"path":"https://github.com/ndpvh/denoiser/reference/noiser.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add noise to the data ‚Äî noiser","text":"data Dataframe contains information location (x- y-coordinates) time measurement taken. default, denoiser() assume information contained within columns \"x\", \"y\", \"time\" respectively. case, either change column names data specify cols argument. cols Named vector named list containing relevant column names data conform prespecified column names \"time\", \"x\", \"y\". labels conform prespecified column names values given locations contain corresponding column names dataset. Defaults NULL, therefore assuming structure explained data. .String denoting whether moving window taken respect given grouping variable. Defaults NULL. model String function denoting model used noising data. providing string, one use one native measurement models package, case value either \"independent\" \"temporal\", calling independent() temporal() model respectively. function, take least data add noise data using default column names (see data). See vignettes information specify function. Defaults \"temporal\". ... Additional arguments provided measurement error models. information, see independent() temporal().","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/noiser.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add noise to the data ‚Äî noiser","text":"Noised data.frame similar structure data","code":""},{"path":[]},{"path":"https://github.com/ndpvh/denoiser/reference/noiser.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add noise to the data ‚Äî noiser","text":"","code":"# Generate data for illustration purposes. Movement in circular motion at a # pace of 1.27m/s with some added noise of SD = 10cm. angles <- seq(0, 4 * pi, length.out = 100) coordinates <- 10 * cbind(cos(angles), sin(angles))  data <- data.frame(   X = coordinates[, 1],   Y = coordinates[, 2],   seconds = rep(1:50, times = 2),   tag = rep(1:2, each = 50) )  # Use the noiser function to add measurement error. We use the independent  # measurement error model with independence between the x- and y-dimension  # and with the measurement error variance being 0.01 in both dimensions noiser(   data,   cols = c(     \"time\" = \"seconds\",     \"x\" = \"X\",     \"y\" = \"Y\"   ),   .by = \"tag\",   model = \"independent\",   covariance = diag(2) * 0.01 ) |>   head() #>   seconds         X         Y tag #> 1       1 10.059094 0.1313144   1 #> 2       2  9.993758 1.2745259   1 #> 3       3  9.610136 2.4484947   1 #> 4       4  9.289626 3.7821316   1 #> 5       5  8.924883 4.8639067   1 #> 6       6  8.180153 5.9987063   1"},{"path":"https://github.com/ndpvh/denoiser/reference/prepare.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare data for analysis ‚Äî prepare","title":"Prepare data for analysis ‚Äî prepare","text":"Function used internally prepare data analysis, either binning (bin()) using Kalman filter (kalman_filter()). preparation consists following steps. First, function checks whether provided data actually data.frame, required functions work properly. , function examines column names argument cols. provided, check whether adhere required format , , change column names data default ones used package (change later undone finalize()). Finally, function check whether grouping variable specified ., prepares data grouping.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/prepare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare data for analysis ‚Äî prepare","text":"","code":"prepare(data, cols = NULL, .by = NULL)"},{"path":"https://github.com/ndpvh/denoiser/reference/prepare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare data for analysis ‚Äî prepare","text":"data Dataframe contains information location (x- y-coordinates) time measurement taken. default, prepare() assume information contained within columns \"x\", \"y\", \"time\" respectively. case, either change column names data specify cols argument. cols Named vector named list containing relevant column names data conform prespecified column names \"time\", \"x\", \"y\". labels conform prespecified column names values given locations contain corresponding column names dataset. Defaults NULL, therefore assuming structure explained data. .String denoting whether moving window taken respect given grouping variable. Defaults NULL.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/prepare.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare data for analysis ‚Äî prepare","text":"Named list containing prepared data.frame (\"data\"), mapping user-specified package-required column names (\"cols\"), values grouping variable (\"group\").","code":""},{"path":[]},{"path":"https://github.com/ndpvh/denoiser/reference/prepare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare data for analysis ‚Äî prepare","text":"","code":"# Generate data for illustration purposes data <- data.frame(   X = rnorm(100),   Y = rnorm(100),   seconds = rep(1:50, times = 2) / 10,   tag = rep(1:2, each = 50) )  # Prepare the data for analysis prepare(   data,   cols = c(     \"time\" = \"seconds\",     \"x\" = \"X\",     \"y\" = \"Y\"   ),   .by = \"tag\" ) #> $data #>     time            x            y id #> 1    0.1  0.358590886 -1.449155712  1 #> 2    0.2 -0.028995035 -0.791503959  1 #> 3    0.3  1.147042072 -0.504480733  1 #> 4    0.4  0.373588935  0.401826700  1 #> 5    0.5  0.323339211  0.971396469  1 #> 6    0.6 -0.829819320 -0.579663020  1 #> 7    0.7  1.394462582  1.604179789  1 #> 8    0.8 -0.191543577  0.225973337  1 #> 9    0.9  0.272277021 -0.514857122  1 #> 10   1.0 -1.081659008 -0.823788240  1 #> 11   1.1 -2.329399361  0.334415250  1 #> 12   1.2 -0.549625959 -0.093490765  1 #> 13   1.3 -0.072579991  0.304062078  1 #> 14   1.4  1.032288404 -0.476507534  1 #> 15   1.5  0.215138526 -0.241311717  1 #> 16   1.6 -0.494340125  0.824155833  1 #> 17   1.7  1.512138281 -1.555643970  1 #> 18   1.8 -0.579463264  0.093501283  1 #> 19   1.9  1.674789634 -0.366949421  1 #> 20   2.0 -1.000980259 -0.129408799  1 #> 21   2.1  1.222702835  0.407795520  1 #> 22   2.2  1.077188166 -0.583968954  1 #> 23   2.3 -0.611945460 -0.193449890  1 #> 24   2.4  0.506866968 -0.269546670  1 #> 25   2.5  0.460068373  0.073658232  1 #> 26   2.6  1.484391861  0.357236138  1 #> 27   2.7  0.881963226  0.550428418  1 #> 28   2.8 -0.536702239  0.038401793  1 #> 29   2.9  1.285553707 -1.609575292  1 #> 30   3.0  0.587848533 -1.049710115  1 #> 31   3.1 -1.308482026  2.052033974  1 #> 32   3.2  0.316726325  0.176436411  1 #> 33   3.3  1.194158303  1.128307358  1 #> 34   3.4  0.913057148  0.435001744  1 #> 35   3.5 -0.786752993  0.548833492  1 #> 36   3.6 -0.410929700  0.647418304  1 #> 37   3.7  0.476373682  0.878463454  1 #> 38   3.8  0.185915868  0.350797869  1 #> 39   3.9 -1.324716253  0.049879720  1 #> 40   4.0  1.172371055  0.835749446  1 #> 41   4.1  0.231492772 -0.281725199  1 #> 42   4.2  0.483071904 -0.791679461  1 #> 43   4.3 -0.535319580  0.001653727  1 #> 44   4.4  1.378135819 -1.187530126  1 #> 45   4.5 -1.302671671  0.362417465  1 #> 46   4.6  0.634857535 -0.549435319  1 #> 47   4.7  0.999655161  0.692949838  1 #> 48   4.8 -0.337748953 -0.060843916  1 #> 49   4.9 -0.086033607 -1.193540930  1 #> 50   5.0 -1.718817584 -0.119908059  1 #> 51   0.1 -0.929121572 -0.708107950  2 #> 52   0.2  0.813676046 -1.616663973  2 #> 53   0.3  0.526413546  0.495847824  2 #> 54   0.4  1.011957390  1.299750970  2 #> 55   0.5  0.831379809 -1.615985506  2 #> 56   0.6  0.415134145 -1.250367945  2 #> 57   0.7 -0.661257061  1.582132306  2 #> 58   0.8  0.548811286  1.252529118  2 #> 59   0.9 -0.539367800 -0.209395701  2 #> 60   1.0 -0.171318426 -0.639033687  2 #> 61   1.1 -0.766734605  0.398902937  2 #> 62   1.2 -0.606574846  1.341973500  2 #> 63   1.3  1.647312821 -0.037607422  2 #> 64   1.4  0.841069348  0.543670114  2 #> 65   1.5  0.338175097  1.740218394  2 #> 66   1.6 -0.404883076 -0.324455939  2 #> 67   1.7  0.900009039 -0.447511333  2 #> 68   1.8  1.190666655  0.416082526  2 #> 69   1.9 -0.047539083 -1.295865368  2 #> 70   2.0  0.786925425  0.682633090  2 #> 71   2.1  1.166684112  0.496913333  2 #> 72   2.2 -0.271823871  1.439660656  2 #> 73   2.3 -0.313704285  1.207358558  2 #> 74   2.4 -0.286300150  0.238514694  2 #> 75   2.5 -0.803440263 -0.298837878  2 #> 76   2.6 -0.094555455  1.384621050  2 #> 77   2.7 -0.074046506 -0.700069022  2 #> 78   2.8  0.714490683  1.860931509  2 #> 79   2.9  0.124718366  1.803924959  2 #> 80   3.0  1.296594339 -1.356043492  2 #> 81   3.1 -1.114492926 -0.314751072  2 #> 82   3.2 -0.842058813 -1.019265181  2 #> 83   3.3 -1.504294209 -0.612249656  2 #> 84   3.4 -0.284026455 -0.289068749  2 #> 85   3.5  0.042869041  1.506983292  2 #> 86   3.6 -0.008866413  0.367722694  2 #> 87   3.7 -2.949083784 -0.020034941  2 #> 88   3.8  0.020358254 -0.979921959  2 #> 89   3.9 -0.098446980 -1.400912333  2 #> 90   4.0  0.589109098  1.445014910  2 #> 91   4.1 -0.425751629 -0.423481621  2 #> 92   4.2  0.634658985 -0.733749597  2 #> 93   4.3 -0.578524902 -0.708484753  2 #> 94   4.4 -0.169109048  1.475092459  2 #> 95   4.5 -1.919232520  0.845004185  2 #> 96   4.6 -1.534266387  1.293994431  2 #> 97   4.7 -1.114761221  0.298161142  2 #> 98   4.8  1.597811635 -0.405682490  2 #> 99   4.9 -0.639805078 -0.138807578  2 #> 100  5.0  1.566690553 -0.222592731  2 #>  #> $cols #>      time         x         y        id  #> \"seconds\"       \"X\"       \"Y\"     \"tag\"  #>  #> $group #> [1] 1 2 #>"},{"path":"https://github.com/ndpvh/denoiser/reference/temporal.html","id":null,"dir":"Reference","previous_headings":"","what":"Add temporal error to data ‚Äî temporal","title":"Add temporal error to data ‚Äî temporal","text":"Error generated vector autoregressive model defining parameters parameters intercept, transition, covariance, specified user. Note temporal component model defined residual level (.e., residuals carry time), data level (positions carried time). See details information.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/temporal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add temporal error to data ‚Äî temporal","text":"","code":"temporal(   data,   intercept = c(0, 0),   transition = matrix(c(0.925, 0.085, 0.085, 0.87), nrow = 2, ncol = 2),   covariance = matrix(c(0.015^2, 0, 0, 0.015^2), nrow = 2, ncol = 2),   sampling_rate = 6.13 )"},{"path":"https://github.com/ndpvh/denoiser/reference/temporal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add temporal error to data ‚Äî temporal","text":"data data.frame containing data base parameters constant velocity model. function assumes data.frame contains columns \"time\", \"x\", \"y\" containing time observed position (x, y) measured respectively. intercept Numeric vector 1 2 values containing intercept vector autoregressive model.1 number provided, value assumed represent intercept x- y- dimensions. Defaults c(0, 0), representing bias system. transition Numeric matrix dimensionality \\(2 \\times 2\\) autoregressive effects diagonal crossregressive effects -diagonal. Defaults autoregressive effects equal 0.925 0.87 x- y-dimension respectively, cross-regressive effects equal 0.085 symmetric way. values represent means parameters found across four days calibration study informed project. covariance Numeric matrix dimensionality \\(2 \\times 2\\), variances errors x y diagonal covariance errors -diagonal. Defaults variances x- y-dimension equal 0.031^2 0.027^2 respectively, covariance equal 0.02. values represent means respective variances covariances found across four days calibration study informed project. sampling_rate Numeric denoting sampling rate Hz. used scale transition matrix according actual sampling rate. Defaults 6.13, mean sampling rate data obtained across four days calibration study informed project. change transition argument, recommended ignore argument.","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/temporal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add temporal error to data ‚Äî temporal","text":"data.frame \"x\" \"y\" columns additional noise .","code":""},{"path":"https://github.com/ndpvh/denoiser/reference/temporal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add temporal error to data ‚Äî temporal","text":"According function, observed positions \\(\\mathbf{y}_i\\) time \\(t_i\\) contain error temporally related, carried time. Specifically, assume error \\(\\mathbf{\\epsilon}_i\\) time \\(t_i\\) depends error \\(\\mathbf{\\epsilon}_{- 1}\\) previous time \\(t_{- 1}\\) white noise residual timepoint, specified vector autoregressive model. symbols: $$\\mathbf{\\epsilon}_i = \\mathbf{\\delta} + \\Theta \\mathbf{\\epsilon}_{- 1} + \\mathbf{\\omega}_i$$ $$\\mathbf{\\omega}_i \\sim N(\\mathbf{0}, \\Sigma)$$ \\(\\mathbf{\\delta}\\) represents intercept model, \\(\\Theta\\) transition matrix defining temporal carry-, \\(\\Sigma\\) covariance matrix white noise residuals \\(\\mathbf{\\omega}\\). Note vector autoregressive model, mean process defined : $$\\mathbf{\\mu} = (- \\Theta)^{-1} \\mathbf{\\delta}$$ useful keep mind specifying intercept add bias system. Furthermore note covariance \\(\\Sigma_\\epsilon\\) process \\(\\mathbf{\\epsilon}\\) defined : $$\\Sigma_\\epsilon = \\Sigma - \\Theta \\Sigma \\Theta^T$$ useful keep mind specifying covariance matrix \\(\\Sigma\\), defined level \\(\\mathbf{\\omega}\\). errors \\(\\mathbf{\\epsilon}_i\\) defined, compute observed positions \\(\\mathbf{y}_i\\) consisting systematic component (.e., latent positions, provided data) unsystematic error component : $$\\mathbf{y}_i = \\mathbf{x}_i + \\mathbf{\\epsilon}_i$$","code":""},{"path":[]},{"path":"https://github.com/ndpvh/denoiser/reference/temporal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add temporal error to data ‚Äî temporal","text":"","code":"# Generate data for illustration purposes. Movement in circular motion at a # pace of 1.27m/s with some added noise of SD = 10cm. angles <- seq(0, 4 * pi, length.out = 100) coordinates <- 10 * cbind(cos(angles), sin(angles))  data <- data.frame(   x = coordinates[, 1],   y = coordinates[, 2],   time = 1:100 )  # Add independent noise to these data with an error variance of 0.01 in each # dimension and a transition matrix containing autoregressive effects of 0.15 temporal(   data,   intercept = c(0, 0),   transition = diag(2) * 0.15,   covariance = diag(2) * 0.01 ) |>   head() #>          x            y time #> 1 9.742460 -0.008170467    1 #> 2 9.871491  1.277113124    2 #> 3 9.724273  2.552381774    3 #> 4 9.212954  3.760601839    4 #> 5 8.605056  4.885181521    5 #> 6 7.844626  6.047900151    6"}]
